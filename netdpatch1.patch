From 36b044d0065dcccc7af33dc8fa78fc9a4695064e Mon Sep 17 00:00:00 2001
From: Pierre Imai <imaipi@google.com>
Date: Fri, 27 May 2016 15:51:55 +0900
Subject: [PATCH 01/23] Silence spammy iptables rule at boot.

BUG: 28529315

(cherry picked from commit 62ffdb7549875bfb20a35b3e877099230e8dc8ac)

Change-Id: I538e057fca909195a9a3a59abd62c059d3d1d036
---


diff --git a/tests/binder_test.cpp b/tests/binder_test.cpp
index 565db99..42d01a5 100644
--- a/tests/binder_test.cpp
+++ b/tests/binder_test.cpp
@@ -117,7 +117,7 @@ static std::vector<std::string> listIpRules(const char *ipVersion) {
 }
 
 static std::vector<std::string> listIptablesRule(const char *binary, const char *chainName) {
-    std::string command = StringPrintf("%s -n -L %s", binary, chainName);
+    std::string command = StringPrintf("%s -w -n -L %s", binary, chainName);
     return runCommand(command);
 }
 

From 002502a10fd28dcafe5c0f43ac2f98c3ade55854 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Fri, 10 Jun 2016 01:54:52 +0900
Subject: [PATCH 03/23] Verify expectations better in SockDiagTest.

Currently SockDiagTest only checks for socket errors, it does not
check that the socket was closed via SOCK_DESTROY. This can cause
us to think that SOCK_DESTROY is working when it isn't.

Fix this by checking the error codes and expecting that at least
one socket was closed by SOCK_DESTROY.

Bug: 28508161

(cherry picked from commit 6bdc41f3fb7e7aef87ef3ee731960c5e720c3acf)

Change-Id: I0e0368145247bfd0f946692381dcd78991811413
---
 server/SockDiagTest.cpp | 42 ++++++++++++++++++++++++------------------
 1 file changed, 24 insertions(+), 18 deletions(-)

diff --git a/server/SockDiagTest.cpp b/server/SockDiagTest.cpp
index 2061a3b..2b1bf02 100644
--- a/server/SockDiagTest.cpp
+++ b/server/SockDiagTest.cpp
@@ -203,7 +203,7 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
 
     constexpr static int MAX_SOCKETS = 500;
     constexpr static int ADDRESS_SOCKETS = 500;
-    constexpr static int UID_SOCKETS = 100;
+    constexpr static int UID_SOCKETS = 50;
     constexpr static uid_t START_UID = 8000;  // START_UID + number of sockets must be <= 9999.
     constexpr static int CLOSE_UID = START_UID + UID_SOCKETS - 42;  // Close to the end
     static_assert(START_UID + MAX_SOCKETS < 9999, "Too many sockets");
@@ -212,10 +212,10 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
         MicroBenchmarkTestType mode = GetParam();
         switch (mode) {
         case ADDRESS:
-            return 500;
+            return ADDRESS_SOCKETS;
         case UID:
         case UIDRANGE:
-            return 50;
+            return UID_SOCKETS;
         }
     }
 
@@ -265,23 +265,26 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
         }
     }
 
-    void checkSocketState(int i, int sock, const char *msg) {
+    bool checkSocketState(int i, int sock, const char *msg) {
         const char data[] = "foo";
         const int ret = send(sock, data, sizeof(data), 0);
         const int err = errno;
-        if (shouldHaveClosedSocket(i)) {
-            EXPECT_EQ(-1, ret) << msg << " " << i << " not closed";
-            if (ret == -1) {
-                // Since we're connected to ourselves, the error might be ECONNABORTED (if we
-                // destroyed the socket) or ECONNRESET (if the other end was destroyed and sent a
-                // RST).
-                EXPECT_TRUE(err == ECONNABORTED || err == ECONNRESET)
-                    << msg << ": unexpected error: " << strerror(err);
-            }
-        } else {
+        if (!shouldHaveClosedSocket(i)) {
             EXPECT_EQ((ssize_t) sizeof(data), ret) <<
                     "Write on open socket failed: " << strerror(err);
+            return false;
         }
+
+        EXPECT_EQ(-1, ret) << msg << " " << i << " not closed";
+        if (ret != -1) {
+            return false;
+        }
+
+        // Since we're connected to ourselves, the error might be ECONNABORTED (if we destroyed the
+        // socket) or ECONNRESET (if the other end was destroyed and sent a RST).
+        EXPECT_TRUE(err == ECONNABORTED || err == ECONNRESET)
+            << msg << ": unexpected error: " << strerror(err);
+        return (err == ECONNABORTED);  // Return true iff. SOCK_DESTROY closed this socket.
     }
 };
 
@@ -330,12 +333,15 @@ TEST_P(SockDiagMicroBenchmarkTest, TestMicroBenchmark) {
             std::chrono::duration_cast<ms>(std::chrono::steady_clock::now() - start).count());
 
     start = std::chrono::steady_clock::now();
+    int socketsClosed = 0;
     for (int i = 0; i < numSockets; i++) {
-        checkSocketState(i, clientsockets[i], "Client socket");
-        checkSocketState(i, serversockets[i], "Server socket");
+        socketsClosed += checkSocketState(i, clientsockets[i], "Client socket");
+        socketsClosed += checkSocketState(i, serversockets[i], "Server socket");
     }
-    fprintf(stderr, "   Verifying: %6.1f ms\n",
-            std::chrono::duration_cast<ms>(std::chrono::steady_clock::now() - start).count());
+    fprintf(stderr, "   Verifying: %6.1f ms (%d sockets destroyed)\n",
+            std::chrono::duration_cast<ms>(std::chrono::steady_clock::now() - start).count(),
+            socketsClosed);
+    EXPECT_GT(socketsClosed, 0);  // Just in case there's a bug in the test.
 
     start = std::chrono::steady_clock::now();
     for (int i = 0; i < numSockets; i++) {

From bc5f0602e12ae915ab6b5e47c8d312e6f3001ecf Mon Sep 17 00:00:00 2001
From: Bryse Flowers <bflowers@codeaurora.org>
Date: Wed, 1 Jun 2016 13:00:12 -0700
Subject: [PATCH 04/23] Listen to xt_quota2 kobject event for quota

Allow quota limit reached notification to originate from both
qlog and xt_quota2 subsystem.  On 3.18 Kernel, modify xt_quota2
module to broadcast the Netlink notification via kobject.

CRs-Fixed: 1008025
Bug: 24140541

(cherry picked from commit 246ca10daf8ac95b7081cebe7e8c06012ced9726)

Change-Id: I33fbf18dbc10a62efdf87ba14d57682d5eb92353
---
 server/NetlinkHandler.cpp | 2 +-
 server/NetlinkManager.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/server/NetlinkHandler.cpp b/server/NetlinkHandler.cpp
index ed21bff..19de240 100644
--- a/server/NetlinkHandler.cpp
+++ b/server/NetlinkHandler.cpp
@@ -116,7 +116,7 @@ void NetlinkHandler::onEvent(NetlinkEvent *evt) {
             }
         }
 
-    } else if (!strcmp(subsys, "qlog")) {
+    } else if (!strcmp(subsys, "qlog") || !strcmp(subsys, "xt_quota2")) {
         const char *alertName = evt->findParam("ALERT_NAME");
         const char *iface = evt->findParam("INTERFACE");
         notifyQuotaLimitReached(alertName, iface);
diff --git a/server/NetlinkManager.cpp b/server/NetlinkManager.cpp
index 76af46f..769a80a 100644
--- a/server/NetlinkManager.cpp
+++ b/server/NetlinkManager.cpp
@@ -142,7 +142,7 @@ int NetlinkManager::start() {
 
     if ((mQuotaHandler = setupSocket(&mQuotaSock, NETLINK_NFLOG,
             NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == NULL) {
-        ALOGE("Unable to open quota socket");
+        ALOGW("Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler");
         // TODO: return -1 once the emulator gets a new kernel.
     }
 

From 1d065ba8b62988b5b92517984d4761c32f00abd3 Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Wed, 8 Jun 2016 13:24:45 +0900
Subject: [PATCH 05/23] Setup interfaces for IPv6 tethering

Including:
    - set the interface for router mode (accept_ra = 0)
    - reset the interface for client mode (accept_ra = 1)
    - InterfaceController::setAcceptIPv6Ra()
    - InterfaceController::setAcceptIPv6Dad()
    - make InterfaceController static
    - refactor for more modern C++ usage here and there
    - sporadic style guide fixes

Bug: 9580643

(cherry picked from commit 2c5aaa1876db659556c2e9605beccc670e6b7c0d)

Change-Id: Ie5825ae3db19bbd8e03130d3bfd7815554214586
---
 server/CommandListener.cpp     | 17 ++++----
 server/Controllers.cpp         |  4 +-
 server/Controllers.h           |  1 -
 server/InterfaceController.cpp | 53 ++++++++++++++++---------
 server/InterfaceController.h   | 29 ++++++++------
 server/TetherController.cpp    | 90 +++++++++++++++++++++---------------------
 server/TetherController.h      | 21 +++++-----
 7 files changed, 118 insertions(+), 97 deletions(-)

diff --git a/server/CommandListener.cpp b/server/CommandListener.cpp
index 1ae1424..bcca44e 100644
--- a/server/CommandListener.cpp
+++ b/server/CommandListener.cpp
@@ -42,6 +42,7 @@
 #include "ResponseCode.h"
 #include "BandwidthController.h"
 #include "IdletimerController.h"
+#include "InterfaceController.h"
 #include "oem_iptables_hook.h"
 #include "NetdConstants.h"
 #include "FirewallController.h"
@@ -413,7 +414,7 @@ int CommandListener::InterfaceCmd::runCommand(SocketClient *cli,
                 return 0;
             }
             int enable = !strncmp(argv[3], "enable", 7);
-            if (gCtls->interfaceCtrl.setIPv6PrivacyExtensions(argv[2], enable) == 0) {
+            if (InterfaceController::setIPv6PrivacyExtensions(argv[2], enable) == 0) {
                 cli->sendMsg(ResponseCode::CommandOkay, "IPv6 privacy extensions changed", false);
             } else {
                 cli->sendMsg(ResponseCode::OperationFailed,
@@ -429,7 +430,7 @@ int CommandListener::InterfaceCmd::runCommand(SocketClient *cli,
             }
 
             int enable = !strncmp(argv[3], "enable", 7);
-            if (gCtls->interfaceCtrl.setEnableIPv6(argv[2], enable) == 0) {
+            if (InterfaceController::setEnableIPv6(argv[2], enable) == 0) {
                 cli->sendMsg(ResponseCode::CommandOkay, "IPv6 state changed", false);
             } else {
                 cli->sendMsg(ResponseCode::OperationFailed,
@@ -444,7 +445,7 @@ int CommandListener::InterfaceCmd::runCommand(SocketClient *cli,
                 return 0;
             }
             int enable = !strncmp(argv[3], "enable", 7);
-            if (gCtls->interfaceCtrl.setIPv6NdOffload(argv[2], enable) == 0) {
+            if (InterfaceController::setIPv6NdOffload(argv[2], enable) == 0) {
                 cli->sendMsg(ResponseCode::CommandOkay, "IPv6 ND offload changed", false);
             } else {
                 cli->sendMsg(ResponseCode::OperationFailed,
@@ -457,7 +458,7 @@ int CommandListener::InterfaceCmd::runCommand(SocketClient *cli,
                         "Usage: interface setmtu <interface> <val>", false);
                 return 0;
             }
-            if (gCtls->interfaceCtrl.setMtu(argv[2], argv[3]) == 0) {
+            if (InterfaceController::setMtu(argv[2], argv[3]) == 0) {
                 cli->sendMsg(ResponseCode::CommandOkay, "MTU changed", false);
             } else {
                 cli->sendMsg(ResponseCode::OperationFailed,
@@ -575,17 +576,15 @@ int CommandListener::TetherCmd::runCommand(SocketClient *cli,
         return 0;
     } else if (argc == 3) {
         if (!strcmp(argv[1], "interface") && !strcmp(argv[2], "list")) {
-            InterfaceCollection *ilist = gCtls->tetherCtrl.getTetheredInterfaceList();
-            InterfaceCollection::iterator it;
-            for (it = ilist->begin(); it != ilist->end(); ++it) {
-                cli->sendMsg(ResponseCode::TetherInterfaceListResult, *it, false);
+            for (const auto &ifname : gCtls->tetherCtrl.getTetheredInterfaceList()) {
+                cli->sendMsg(ResponseCode::TetherInterfaceListResult, ifname.c_str(), false);
             }
         } else if (!strcmp(argv[1], "dns") && !strcmp(argv[2], "list")) {
             char netIdStr[UINT32_STRLEN];
             snprintf(netIdStr, sizeof(netIdStr), "%u", gCtls->tetherCtrl.getDnsNetId());
             cli->sendMsg(ResponseCode::TetherDnsFwdNetIdResult, netIdStr, false);
 
-            for (const auto &fwdr : *(gCtls->tetherCtrl.getDnsForwarders())) {
+            for (const auto &fwdr : gCtls->tetherCtrl.getDnsForwarders()) {
                 cli->sendMsg(ResponseCode::TetherDnsFwdTgtListResult, fwdr.c_str(), false);
             }
         }
diff --git a/server/Controllers.cpp b/server/Controllers.cpp
index 07e5653..85c7c96 100644
--- a/server/Controllers.cpp
+++ b/server/Controllers.cpp
@@ -19,7 +19,9 @@
 namespace android {
 namespace net {
 
-Controllers::Controllers() : clatdCtrl(&netCtrl) {}
+Controllers::Controllers() : clatdCtrl(&netCtrl) {
+    InterfaceController::initializeAll();
+}
 
 Controllers* gCtls = nullptr;
 
diff --git a/server/Controllers.h b/server/Controllers.h
index 9720a15..6ee8721 100644
--- a/server/Controllers.h
+++ b/server/Controllers.h
@@ -45,7 +45,6 @@ struct Controllers {
     IdletimerController idletimerCtrl;
     ResolverController resolverCtrl;
     FirewallController firewallCtrl;
-    InterfaceController interfaceCtrl;
     ClatdController clatdCtrl;
     StrictController strictCtrl;
 };
diff --git a/server/InterfaceController.cpp b/server/InterfaceController.cpp
index a9cf48f..cbc3611 100644
--- a/server/InterfaceController.cpp
+++ b/server/InterfaceController.cpp
@@ -82,28 +82,25 @@ void setIPv6UseOutgoingInterfaceAddrsOnly(const char *value) {
 
 }  // namespace
 
-InterfaceController::InterfaceController() {
-	// Initial IPv6 settings.
-	// By default, accept_ra is set to 1 (accept RAs unless forwarding is on) on all interfaces.
-	// This causes RAs to work or not work based on whether forwarding is on, and causes routes
-	// learned from RAs to go away when forwarding is turned on. Make this behaviour predictable
-	// by always setting accept_ra to 2.
-	setAcceptRA("2");
+void InterfaceController::initializeAll() {
+    // Initial IPv6 settings.
+    // By default, accept_ra is set to 1 (accept RAs unless forwarding is on) on all interfaces.
+    // This causes RAs to work or not work based on whether forwarding is on, and causes routes
+    // learned from RAs to go away when forwarding is turned on. Make this behaviour predictable
+    // by always setting accept_ra to 2.
+    setAcceptRA("2");
 
-	setAcceptRARouteTable(-RouteController::ROUTE_TABLE_OFFSET_FROM_INDEX);
+    setAcceptRARouteTable(-RouteController::ROUTE_TABLE_OFFSET_FROM_INDEX);
 
-	// Enable optimistic DAD for IPv6 addresses on all interfaces.
-	setIPv6OptimisticMode("1");
+    // Enable optimistic DAD for IPv6 addresses on all interfaces.
+    setIPv6OptimisticMode("1");
 
-	// Reduce the ARP/ND base reachable time from the default (30sec) to 15sec.
-	setBaseReachableTimeMs(15 * 1000);
+    // Reduce the ARP/ND base reachable time from the default (30sec) to 15sec.
+    setBaseReachableTimeMs(15 * 1000);
 
-	// When sending traffic via a given interface use only addresses configured
-        // on that interface as possible source addresses.
-	setIPv6UseOutgoingInterfaceAddrsOnly("1");
-}
-
-InterfaceController::~InterfaceController() {
+    // When sending traffic via a given interface use only addresses configured
+       // on that interface as possible source addresses.
+    setIPv6UseOutgoingInterfaceAddrsOnly("1");
 }
 
 int InterfaceController::setEnableIPv6(const char *interface, const int on) {
@@ -118,6 +115,26 @@ int InterfaceController::setEnableIPv6(const char *interface, const int on) {
     return writeValueToPath(ipv6_proc_path, interface, "disable_ipv6", disable_ipv6);
 }
 
+int InterfaceController::setAcceptIPv6Ra(const char *interface, const int on) {
+    if (!isIfaceName(interface)) {
+        errno = ENOENT;
+        return -1;
+    }
+    // Because forwarding can be enabled even when tethering is off, we always
+    // use mode "2" (accept RAs, even if forwarding is enabled).
+    const char *accept_ra = on ? "2" : "0";
+    return writeValueToPath(ipv6_proc_path, interface, "accept_ra", accept_ra);
+}
+
+int InterfaceController::setAcceptIPv6Dad(const char *interface, const int on) {
+    if (!isIfaceName(interface)) {
+        errno = ENOENT;
+        return -1;
+    }
+    const char *accept_dad = on ? "1" : "0";
+    return writeValueToPath(ipv6_proc_path, interface, "accept_dad", accept_dad);
+}
+
 int InterfaceController::setIPv6PrivacyExtensions(const char *interface, const int on) {
     if (!isIfaceName(interface)) {
         errno = ENOENT;
diff --git a/server/InterfaceController.h b/server/InterfaceController.h
index 89728b1..4c8057e 100644
--- a/server/InterfaceController.h
+++ b/server/InterfaceController.h
@@ -18,19 +18,24 @@
 #define _INTERFACE_CONTROLLER_H
 
 class InterfaceController {
- public:
-	InterfaceController();
-	virtual ~InterfaceController();
-	int setEnableIPv6(const char *interface, const int on);
-	int setIPv6PrivacyExtensions(const char *interface, const int on);
-	int setIPv6NdOffload(char* interface, const int on);
-	int setMtu(const char *interface, const char *mtu);
+public:
+    static void initializeAll();
 
- private:
-	void setAcceptRA(const char* value);
-	void setAcceptRARouteTable(int tableOrOffset);
-	void setBaseReachableTimeMs(unsigned int millis);
-	void setIPv6OptimisticMode(const char *value);
+    static int setEnableIPv6(const char *interface, const int on);
+    static int setAcceptIPv6Ra(const char *interface, const int on);
+    static int setAcceptIPv6Dad(const char *interface, const int on);
+    static int setIPv6PrivacyExtensions(const char *interface, const int on);
+    static int setIPv6NdOffload(char* interface, const int on);
+    static int setMtu(const char *interface, const char *mtu);
+
+private:
+    static void setAcceptRA(const char* value);
+    static void setAcceptRARouteTable(int tableOrOffset);
+    static void setBaseReachableTimeMs(unsigned int millis);
+    static void setIPv6OptimisticMode(const char *value);
+
+    InterfaceController() = delete;
+    ~InterfaceController() = delete;
 };
 
 #endif
diff --git a/server/TetherController.cpp b/server/TetherController.cpp
index dbbd933..971104f 100644
--- a/server/TetherController.cpp
+++ b/server/TetherController.cpp
@@ -35,14 +35,15 @@
 #include "Fwmark.h"
 #include "NetdConstants.h"
 #include "Permission.h"
+#include "InterfaceController.h"
 #include "TetherController.h"
 
 namespace {
 
-static const char BP_TOOLS_MODE[] = "bp-tools";
-static const char IPV4_FORWARDING_PROC_FILE[] = "/proc/sys/net/ipv4/ip_forward";
-static const char IPV6_FORWARDING_PROC_FILE[] = "/proc/sys/net/ipv6/conf/all/forwarding";
-static const char SEPARATOR[] = "|";
+const char BP_TOOLS_MODE[] = "bp-tools";
+const char IPV4_FORWARDING_PROC_FILE[] = "/proc/sys/net/ipv4/ip_forward";
+const char IPV6_FORWARDING_PROC_FILE[] = "/proc/sys/net/ipv6/conf/all/forwarding";
+const char SEPARATOR[] = "|";
 
 bool writeToFile(const char* filename, const char* value) {
     int fd = open(filename, O_WRONLY);
@@ -61,6 +62,17 @@ bool writeToFile(const char* filename, const char* value) {
     return true;
 }
 
+bool configureForIPv6Router(const char *interface) {
+    return (InterfaceController::setEnableIPv6(interface, 0) == 0)
+            && (InterfaceController::setAcceptIPv6Ra(interface, 0) == 0)
+            && (InterfaceController::setEnableIPv6(interface, 1) == 0);
+}
+
+void configureForIPv6Client(const char *interface) {
+    InterfaceController::setAcceptIPv6Ra(interface, 1);
+    InterfaceController::setEnableIPv6(interface, 0);
+}
+
 bool inBpToolsMode() {
     // In BP tools mode, do not disable IP forwarding
     char bootmode[PROPERTY_VALUE_MAX] = {0};
@@ -71,9 +83,7 @@ bool inBpToolsMode() {
 }  // namespace
 
 TetherController::TetherController() {
-    mInterfaces = new InterfaceCollection();
     mDnsNetId = 0;
-    mDnsForwarders = new NetAddressCollection();
     mDaemonFd = -1;
     mDaemonPid = 0;
     if (inBpToolsMode()) {
@@ -84,14 +94,8 @@ TetherController::TetherController() {
 }
 
 TetherController::~TetherController() {
-    InterfaceCollection::iterator it;
-
-    for (it = mInterfaces->begin(); it != mInterfaces->end(); ++it) {
-        free(*it);
-    }
-    mInterfaces->clear();
-
-    mDnsForwarders->clear();
+    mInterfaces.clear();
+    mDnsForwarders.clear();
     mForwardingRequests.clear();
 }
 
@@ -233,7 +237,7 @@ int TetherController::setDnsForwarders(unsigned netId, char **servers, int numSe
     snprintf(daemonCmd, sizeof(daemonCmd), "update_dns%s0x%x", SEPARATOR, fwmark.intValue);
     int cmdLen = strlen(daemonCmd);
 
-    mDnsForwarders->clear();
+    mDnsForwarders.clear();
     for (i = 0; i < numServers; i++) {
         ALOGD("setDnsForwarders(0x%x %d = '%s')", fwmark.intValue, i, servers[i]);
 
@@ -242,7 +246,7 @@ int TetherController::setDnsForwarders(unsigned netId, char **servers, int numSe
         freeaddrinfo(res);
         if (ret) {
             ALOGE("Failed to parse DNS server '%s'", servers[i]);
-            mDnsForwarders->clear();
+            mDnsForwarders.clear();
             errno = EINVAL;
             return -1;
         }
@@ -255,7 +259,7 @@ int TetherController::setDnsForwarders(unsigned netId, char **servers, int numSe
 
         strcat(daemonCmd, SEPARATOR);
         strcat(daemonCmd, servers[i]);
-        mDnsForwarders->push_back(servers[i]);
+        mDnsForwarders.push_back(servers[i]);
     }
 
     mDnsNetId = netId;
@@ -263,7 +267,7 @@ int TetherController::setDnsForwarders(unsigned netId, char **servers, int numSe
         ALOGD("Sending update msg to dnsmasq [%s]", daemonCmd);
         if (write(mDaemonFd, daemonCmd, strlen(daemonCmd) +1) < 0) {
             ALOGE("Failed to send update command to dnsmasq (%s)", strerror(errno));
-            mDnsForwarders->clear();
+            mDnsForwarders.clear();
             errno = EREMOTEIO;
             return -1;
         }
@@ -275,27 +279,26 @@ unsigned TetherController::getDnsNetId() {
     return mDnsNetId;
 }
 
-NetAddressCollection *TetherController::getDnsForwarders() {
+const std::list<std::string> &TetherController::getDnsForwarders() const {
     return mDnsForwarders;
 }
 
-int TetherController::applyDnsInterfaces() {
+bool TetherController::applyDnsInterfaces() {
     char daemonCmd[MAX_CMD_SIZE];
 
     strcpy(daemonCmd, "update_ifaces");
     int cmdLen = strlen(daemonCmd);
-    InterfaceCollection::iterator it;
     bool haveInterfaces = false;
 
-    for (it = mInterfaces->begin(); it != mInterfaces->end(); ++it) {
-        cmdLen += (strlen(*it) + 1);
+    for (const auto &ifname : mInterfaces) {
+        cmdLen += (ifname.size() + 1);
         if (cmdLen + 1 >= MAX_CMD_SIZE) {
             ALOGD("Too many DNS ifaces listed");
             break;
         }
 
         strcat(daemonCmd, SEPARATOR);
-        strcat(daemonCmd, *it);
+        strcat(daemonCmd, ifname.c_str());
         haveInterfaces = true;
     }
 
@@ -303,10 +306,10 @@ int TetherController::applyDnsInterfaces() {
         ALOGD("Sending update msg to dnsmasq [%s]", daemonCmd);
         if (write(mDaemonFd, daemonCmd, strlen(daemonCmd) +1) < 0) {
             ALOGE("Failed to send update command to dnsmasq (%s)", strerror(errno));
-            return -1;
+            return false;
         }
     }
-    return 0;
+    return true;
 }
 
 int TetherController::tetherInterface(const char *interface) {
@@ -315,17 +318,16 @@ int TetherController::tetherInterface(const char *interface) {
         errno = ENOENT;
         return -1;
     }
-    mInterfaces->push_back(strdup(interface));
-
-    if (applyDnsInterfaces()) {
-        InterfaceCollection::iterator it;
-        for (it = mInterfaces->begin(); it != mInterfaces->end(); ++it) {
-            if (!strcmp(interface, *it)) {
-                free(*it);
-                mInterfaces->erase(it);
-                break;
-            }
-        }
+
+    if (!configureForIPv6Router(interface)) {
+        configureForIPv6Client(interface);
+        return -1;
+    }
+    mInterfaces.push_back(interface);
+
+    if (!applyDnsInterfaces()) {
+        mInterfaces.pop_back();
+        configureForIPv6Client(interface);
         return -1;
     } else {
         return 0;
@@ -333,22 +335,20 @@ int TetherController::tetherInterface(const char *interface) {
 }
 
 int TetherController::untetherInterface(const char *interface) {
-    InterfaceCollection::iterator it;
-
     ALOGD("untetherInterface(%s)", interface);
 
-    for (it = mInterfaces->begin(); it != mInterfaces->end(); ++it) {
-        if (!strcmp(interface, *it)) {
-            free(*it);
-            mInterfaces->erase(it);
+    for (auto it = mInterfaces.cbegin(); it != mInterfaces.cend(); ++it) {
+        if (!strcmp(interface, it->c_str())) {
+            mInterfaces.erase(it);
 
-            return applyDnsInterfaces();
+            configureForIPv6Client(interface);
+            return applyDnsInterfaces() ? 0 : -1;
         }
     }
     errno = ENOENT;
     return -1;
 }
 
-InterfaceCollection *TetherController::getTetheredInterfaceList() {
+const std::list<std::string> &TetherController::getTetheredInterfaceList() const {
     return mInterfaces;
 }
diff --git a/server/TetherController.h b/server/TetherController.h
index 0aa19f2..6035c25 100644
--- a/server/TetherController.h
+++ b/server/TetherController.h
@@ -23,18 +23,17 @@
 #include <set>
 #include <string>
 
-typedef std::list<char *> InterfaceCollection;
-typedef std::list<std::string> NetAddressCollection;
 
 class TetherController {
-    InterfaceCollection  *mInterfaces;
+private:
+    std::list<std::string> mInterfaces;
     // NetId to use for forwarded DNS queries. This may not be the default
     // network, e.g., in the case where we are tethering to a DUN APN.
-    unsigned              mDnsNetId;
-    NetAddressCollection *mDnsForwarders;
-    pid_t                 mDaemonPid;
-    int                   mDaemonFd;
-    std::set<std::string> mForwardingRequests;
+    unsigned               mDnsNetId;
+    std::list<std::string> mDnsForwarders;
+    pid_t                  mDaemonPid;
+    int                    mDaemonFd;
+    std::set<std::string>  mForwardingRequests;
 
 public:
     TetherController();
@@ -50,14 +49,14 @@ class TetherController {
 
     unsigned getDnsNetId();
     int setDnsForwarders(unsigned netId, char **servers, int numServers);
-    NetAddressCollection *getDnsForwarders();
+    const std::list<std::string> &getDnsForwarders() const;
 
     int tetherInterface(const char *interface);
     int untetherInterface(const char *interface);
-    InterfaceCollection *getTetheredInterfaceList();
+    const std::list<std::string> &getTetheredInterfaceList() const;
 
 private:
-    int applyDnsInterfaces();
+    bool applyDnsInterfaces();
     bool setIpFwdEnabled();
 };
 

From b88ae11d21377b6499a07d24be7cc2bf51dd1601 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Fri, 8 Jul 2016 18:24:26 +0900
Subject: [PATCH 06/23] Add a test for getTetherStats.

(cherry picked from commit bbeaf9a4d272eefb11748d7d40c6bd117ab468fb)

Bug: 9580643
Change-Id: Ice734897e66e299b4db39ad369087e0f8fa263c0
---
 server/Android.mk                  |  3 +-
 server/BandwidthControllerTest.cpp | 71 +++++++++++++++++++++++++++++++++++---
 server/IptablesBaseTest.cpp        | 17 +++++++++
 server/IptablesBaseTest.h          |  4 +++
 4 files changed, 90 insertions(+), 5 deletions(-)

diff --git a/server/Android.mk b/server/Android.mk
index 1c7f9cc..97e4790 100644
--- a/server/Android.mk
+++ b/server/Android.mk
@@ -143,11 +143,12 @@ LOCAL_SRC_FILES := \
         NetdConstants.cpp IptablesBaseTest.cpp \
         BandwidthController.cpp BandwidthControllerTest.cpp \
         FirewallControllerTest.cpp FirewallController.cpp \
+        NatController.cpp \
         SockDiagTest.cpp SockDiag.cpp \
         StrictController.cpp StrictControllerTest.cpp \
         UidRanges.cpp \
 
 LOCAL_MODULE_TAGS := tests
-LOCAL_SHARED_LIBRARIES := liblog libbase libcutils liblogwrap
+LOCAL_SHARED_LIBRARIES := liblog libbase libcutils liblogwrap libsysutils
 include $(BUILD_NATIVE_TEST)
 
diff --git a/server/BandwidthControllerTest.cpp b/server/BandwidthControllerTest.cpp
index aa24583..5af9749 100644
--- a/server/BandwidthControllerTest.cpp
+++ b/server/BandwidthControllerTest.cpp
@@ -19,6 +19,11 @@
 #include <string>
 #include <vector>
 
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
 #include <gtest/gtest.h>
 
 #include <android-base/strings.h>
@@ -26,10 +31,6 @@
 #include "BandwidthController.h"
 #include "IptablesBaseTest.h"
 
-FILE *fake_popen(const char *, const char *) {
-    return NULL;
-};
-
 class BandwidthControllerTest : public IptablesBaseTest {
 public:
     BandwidthControllerTest() {
@@ -38,6 +39,10 @@ class BandwidthControllerTest : public IptablesBaseTest {
         BandwidthController::iptablesRestoreFunction = fakeExecIptablesRestore;
     }
     BandwidthController mBw;
+
+    void addPopenContents(std::string contents) {
+        sPopenContents.push_back(contents);
+    }
 };
 
 TEST_F(BandwidthControllerTest, TestSetupIptablesHooks) {
@@ -134,3 +139,61 @@ TEST_F(BandwidthControllerTest, TestEnableDataSaver) {
     };
     expectIptablesCommands(expected);
 }
+
+std::string kIPv4TetherCounters = android::base::Join(std::vector<std::string> {
+    "Chain natctrl_tether_counters (4 references)",
+    "    pkts      bytes target     prot opt in     out     source               destination",
+    "      26     2373 RETURN     all  --  wlan0  rmnet0  0.0.0.0/0            0.0.0.0/0",
+    "      27     2002 RETURN     all  --  rmnet0 wlan0   0.0.0.0/0            0.0.0.0/0",
+    "    1040   107471 RETURN     all  --  bt-pan rmnet0  0.0.0.0/0            0.0.0.0/0",
+    "    1450  1708806 RETURN     all  --  rmnet0 bt-pan  0.0.0.0/0            0.0.0.0/0",
+}, '\n');
+
+std::string readSocketClientResponse(int fd) {
+    char buf[32768];
+    ssize_t bytesRead = read(fd, buf, sizeof(buf));
+    if (bytesRead < 0) {
+        return "";
+    }
+    for (int i = 0; i < bytesRead; i++) {
+        if (buf[i] == '\0') buf[i] = '\n';
+    }
+    return std::string(buf, bytesRead);
+}
+
+TEST_F(BandwidthControllerTest, TestGetTetherStats) {
+    int socketPair[2];
+    ASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, socketPair));
+    ASSERT_EQ(0, fcntl(socketPair[0], F_SETFL, O_NONBLOCK | fcntl(socketPair[0], F_GETFL)));
+    ASSERT_EQ(0, fcntl(socketPair[1], F_SETFL, O_NONBLOCK | fcntl(socketPair[1], F_GETFL)));
+    SocketClient cli(socketPair[0], false);
+
+    std::string err;
+    BandwidthController::TetherStats filter;
+    addPopenContents(kIPv4TetherCounters);
+    std::string expected =
+            "114 wlan0 rmnet0 2373 26 2002 27\n"
+            "114 bt-pan rmnet0 107471 1040 1708806 1450\n"
+            "200 Tethering stats list completed\n";
+    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+
+    addPopenContents(kIPv4TetherCounters);
+    filter = BandwidthController::TetherStats("bt-pan", "rmnet0", -1, -1, -1, -1);
+    expected = "221 bt-pan rmnet0 107471 1040 1708806 1450\n";
+    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+
+
+    addPopenContents(kIPv4TetherCounters);
+    filter = BandwidthController::TetherStats("rmnet0", "wlan0", -1, -1, -1, -1);
+    expected = "221 rmnet0 wlan0 2002 27 2373 26\n";
+    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+
+    addPopenContents(kIPv4TetherCounters);
+    filter = BandwidthController::TetherStats("rmnet0", "foo0", -1, -1, -1, -1);
+    expected = "200 Tethering stats list completed\n";
+    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+}
diff --git a/server/IptablesBaseTest.cpp b/server/IptablesBaseTest.cpp
index 1502c4b..9e75cb6 100644
--- a/server/IptablesBaseTest.cpp
+++ b/server/IptablesBaseTest.cpp
@@ -16,14 +16,20 @@
  * IptablesBaseTest.cpp - utility class for tests that use iptables
  */
 
+#include <deque>
 #include <string>
 #include <vector>
 
 #include <gtest/gtest.h>
 
+#include <android-base/stringprintf.h>
+
 #include "IptablesBaseTest.h"
 #include "NetdConstants.h"
 
+#define LOG_TAG "IptablesBaseTest"
+#include <cutils/log.h>
+
 IptablesBaseTest::IptablesBaseTest() {
     sCmds.clear();
     sRestoreCmds.clear();
@@ -63,6 +69,16 @@ int IptablesBaseTest::fakeExecIptables(IptablesTarget target, ...) {
     return 0;
 }
 
+FILE *IptablesBaseTest::fake_popen(const char * /* cmd */, const char *type) {
+    if (sPopenContents.empty() || strcmp(type, "r") != 0) {
+        return NULL;
+    }
+
+    std::string realCmd = android::base::StringPrintf("echo '%s'", sPopenContents.front().c_str());
+    sPopenContents.pop_front();
+    return popen(realCmd.c_str(), "r");
+}
+
 int IptablesBaseTest::fakeExecIptablesRestore(IptablesTarget target, const std::string& commands) {
     sRestoreCmds.push_back({ target, commands });
     return 0;
@@ -131,3 +147,4 @@ void IptablesBaseTest::expectIptablesRestoreCommands(const ExpectedIptablesComma
 
 std::vector<std::string> IptablesBaseTest::sCmds = {};
 IptablesBaseTest::ExpectedIptablesCommands IptablesBaseTest::sRestoreCmds = {};
+std::deque<std::string> IptablesBaseTest::sPopenContents = {};
diff --git a/server/IptablesBaseTest.h b/server/IptablesBaseTest.h
index a8521b1..a354ef2 100644
--- a/server/IptablesBaseTest.h
+++ b/server/IptablesBaseTest.h
@@ -16,6 +16,8 @@
  * IptablesBaseTest.h - utility class for tests that use iptables
  */
 
+#include <deque>
+
 #include "NetdConstants.h"
 
 class IptablesBaseTest : public ::testing::Test {
@@ -27,6 +29,7 @@ class IptablesBaseTest : public ::testing::Test {
     static int fake_android_fork_exec(int argc, char* argv[], int *status, bool, bool);
     static int fakeExecIptables(IptablesTarget target, ...);
     static int fakeExecIptablesRestore(IptablesTarget target, const std::string& commands);
+    static FILE *fake_popen(const char *cmd, const char *type);
     void expectIptablesCommands(const std::vector<std::string>& expectedCmds);
     void expectIptablesCommands(const ExpectedIptablesCommands& expectedCmds);
     void expectIptablesRestoreCommands(const std::vector<std::string>& expectedCmds);
@@ -35,5 +38,6 @@ class IptablesBaseTest : public ::testing::Test {
 protected:
     static std::vector<std::string> sCmds;
     static ExpectedIptablesCommands sRestoreCmds;
+    static std::deque<std::string> sPopenContents;
     int expectIptablesCommand(IptablesTarget target, int pos, const std::string& cmd);
 };

From 08a30b997792a8ea13ebdfe6363e623c1161b1e5 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Sat, 9 Jul 2016 14:24:08 +0900
Subject: [PATCH 07/23] Add a test for NatController.

Bug: 9580643

(cherry picked from commit 8e1cee9064af5b2e0d8095d5a6a05953616d7d4c)

Change-Id: I1cb66b503885073c653f6e8ce527356c8ce04557
---
 server/Android.mk            |   2 +-
 server/IptablesBaseTest.cpp  |  14 ++++-
 server/IptablesBaseTest.h    |   2 +
 server/NatController.cpp     |   4 +-
 server/NatController.h       |   4 ++
 server/NatControllerTest.cpp | 140 +++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 163 insertions(+), 3 deletions(-)
 create mode 100644 server/NatControllerTest.cpp

diff --git a/server/Android.mk b/server/Android.mk
index 97e4790..da7c942 100644
--- a/server/Android.mk
+++ b/server/Android.mk
@@ -143,7 +143,7 @@ LOCAL_SRC_FILES := \
         NetdConstants.cpp IptablesBaseTest.cpp \
         BandwidthController.cpp BandwidthControllerTest.cpp \
         FirewallControllerTest.cpp FirewallController.cpp \
-        NatController.cpp \
+        NatControllerTest.cpp NatController.cpp \
         SockDiagTest.cpp SockDiag.cpp \
         StrictController.cpp StrictControllerTest.cpp \
         UidRanges.cpp \
diff --git a/server/IptablesBaseTest.cpp b/server/IptablesBaseTest.cpp
index 9e75cb6..b52ff9b 100644
--- a/server/IptablesBaseTest.cpp
+++ b/server/IptablesBaseTest.cpp
@@ -38,11 +38,14 @@ IptablesBaseTest::IptablesBaseTest() {
 int IptablesBaseTest::fake_android_fork_exec(int argc, char* argv[], int *status, bool, bool) {
     std::string cmd = argv[0];
     for (int i = 1; i < argc; i++) {
+        if (argv[i] == NULL) break;  // NatController likes to pass in invalid argc values.
         cmd += " ";
         cmd += argv[i];
     }
     sCmds.push_back(cmd);
-    *status = 0;
+    if (status) {
+        *status = 0;
+    }
     return 0;
 }
 
@@ -128,6 +131,15 @@ void IptablesBaseTest::expectIptablesCommands(const ExpectedIptablesCommands& ex
     sCmds.clear();
 }
 
+void IptablesBaseTest::expectIptablesCommands(
+        const std::vector<ExpectedIptablesCommands>& snippets) {
+    ExpectedIptablesCommands expected;
+    for (const auto& snippet: snippets) {
+        expected.insert(expected.end(), snippet.begin(), snippet.end());
+    }
+    expectIptablesCommands(expected);
+}
+
 void IptablesBaseTest::expectIptablesRestoreCommands(const std::vector<std::string>& expectedCmds) {
     ExpectedIptablesCommands expected;
     for (auto cmd : expectedCmds) {
diff --git a/server/IptablesBaseTest.h b/server/IptablesBaseTest.h
index a354ef2..d175c5b 100644
--- a/server/IptablesBaseTest.h
+++ b/server/IptablesBaseTest.h
@@ -27,11 +27,13 @@ class IptablesBaseTest : public ::testing::Test {
     typedef std::vector<std::pair<IptablesTarget, std::string>> ExpectedIptablesCommands;
 
     static int fake_android_fork_exec(int argc, char* argv[], int *status, bool, bool);
+    static int fake_android_fork_execvp(int argc, char* argv[], int *status, bool, bool);
     static int fakeExecIptables(IptablesTarget target, ...);
     static int fakeExecIptablesRestore(IptablesTarget target, const std::string& commands);
     static FILE *fake_popen(const char *cmd, const char *type);
     void expectIptablesCommands(const std::vector<std::string>& expectedCmds);
     void expectIptablesCommands(const ExpectedIptablesCommands& expectedCmds);
+    void expectIptablesCommands(const std::vector<ExpectedIptablesCommands>& snippets);
     void expectIptablesRestoreCommands(const std::vector<std::string>& expectedCmds);
     void expectIptablesRestoreCommands(const ExpectedIptablesCommands& expectedCmds);
 
diff --git a/server/NatController.cpp b/server/NatController.cpp
index 19d19c7..fba96ca 100644
--- a/server/NatController.cpp
+++ b/server/NatController.cpp
@@ -40,6 +40,8 @@ const char* NatController::LOCAL_MANGLE_FORWARD = "natctrl_mangle_FORWARD";
 const char* NatController::LOCAL_NAT_POSTROUTING = "natctrl_nat_POSTROUTING";
 const char* NatController::LOCAL_TETHER_COUNTERS_CHAIN = "natctrl_tether_counters";
 
+auto NatController::execFunction = android_fork_execvp;
+
 NatController::NatController() {
 }
 
@@ -55,7 +57,7 @@ struct CommandsAndArgs {
 int NatController::runCmd(int argc, const char **argv) {
     int res;
 
-    res = android_fork_execvp(argc, (char **)argv, NULL, false, false);
+    res = execFunction(argc, (char **)argv, NULL, false, false);
 
 #if !LOG_NDEBUG
     std::string full_cmd = argv[0];
diff --git a/server/NatController.h b/server/NatController.h
index f23bf84..500385b 100644
--- a/server/NatController.h
+++ b/server/NatController.h
@@ -47,6 +47,10 @@ class NatController {
     int runCmd(int argc, const char **argv);
     int setForwardRules(bool set, const char *intIface, const char *extIface);
     int setTetherCountingRules(bool add, const char *intIface, const char *extIface);
+
+    // For testing.
+    friend class NatControllerTest;
+    static int (*execFunction)(int, char **, int *, bool, bool);
 };
 
 #endif
diff --git a/server/NatControllerTest.cpp b/server/NatControllerTest.cpp
new file mode 100644
index 0000000..551efc6
--- /dev/null
+++ b/server/NatControllerTest.cpp
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * NatControllerTest.cpp - unit tests for NatController.cpp
+ */
+
+#include <string>
+#include <vector>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <gtest/gtest.h>
+
+#include <android-base/stringprintf.h>
+#include <android-base/strings.h>
+
+#include "NatController.h"
+#include "IptablesBaseTest.h"
+
+using android::base::StringPrintf;
+
+class NatControllerTest : public IptablesBaseTest {
+public:
+    NatControllerTest() {
+        NatController::execFunction = fake_android_fork_exec;
+    }
+
+protected:
+    NatController mNatCtrl;
+
+    int setDefaults() {
+        return mNatCtrl.setDefaults();
+    }
+
+    const ExpectedIptablesCommands FLUSH_COMMANDS = {
+        { V4, "-F natctrl_FORWARD" },
+        { V4, "-A natctrl_FORWARD -j DROP" },
+        { V4, "-t nat -F natctrl_nat_POSTROUTING" },
+    };
+
+    const ExpectedIptablesCommands SETUP_COMMANDS = {
+        { V4, "-F natctrl_FORWARD" },
+        { V4, "-A natctrl_FORWARD -j DROP" },
+        { V4, "-t nat -F natctrl_nat_POSTROUTING" },
+        { V4, "-F natctrl_tether_counters" },
+        { V4, "-X natctrl_tether_counters" },
+        { V4, "-N natctrl_tether_counters" },
+        { V4, "-t mangle -A natctrl_mangle_FORWARD -p tcp --tcp-flags SYN SYN "
+              "-j TCPMSS --clamp-mss-to-pmtu" },
+    };
+
+    const ExpectedIptablesCommands TWIDDLE_COMMANDS = {
+        { V4, "-D natctrl_FORWARD -j DROP" },
+        { V4, "-A natctrl_FORWARD -j DROP" },
+    };
+
+    ExpectedIptablesCommands enableMasqueradeCommand(const char *extIf) {
+        return {
+            { V4, StringPrintf("-t nat -A natctrl_nat_POSTROUTING -o %s -j MASQUERADE", extIf) },
+        };
+    }
+
+    ExpectedIptablesCommands startNatCommands(const char *intIf, const char *extIf) {
+        return {
+            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state"
+                               " ESTABLISHED,RELATED -g natctrl_tether_counters", extIf, intIf) },
+            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state INVALID -j DROP",
+                               intIf, extIf) },
+            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
+                               intIf, extIf) },
+            { V4, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN", intIf, extIf) },
+            { V4, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN", extIf, intIf) },
+        };
+    }
+
+    ExpectedIptablesCommands stopNatCommands(const char *intIf, const char *extIf) {
+        return {
+            { V4, StringPrintf("-D natctrl_FORWARD -i %s -o %s -m state --state"
+                               " ESTABLISHED,RELATED -g natctrl_tether_counters", extIf, intIf) },
+            { V4, StringPrintf("-D natctrl_FORWARD -i %s -o %s -m state --state INVALID -j DROP",
+                               intIf, extIf) },
+            { V4, StringPrintf("-D natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
+                               intIf, extIf) },
+        };
+    }
+};
+
+TEST_F(NatControllerTest, TestSetupIptablesHooks) {
+    mNatCtrl.setupIptablesHooks();
+    expectIptablesCommands(SETUP_COMMANDS);
+}
+
+TEST_F(NatControllerTest, TestSetDefaults) {
+    setDefaults();
+    expectIptablesCommands(FLUSH_COMMANDS);
+}
+
+TEST_F(NatControllerTest, TestAddAndRemoveNat) {
+
+    std::vector<ExpectedIptablesCommands> startFirstNat = {
+        enableMasqueradeCommand("rmnet0"),
+        startNatCommands("wlan0", "rmnet0"),
+        TWIDDLE_COMMANDS,
+    };
+    mNatCtrl.enableNat("wlan0", "rmnet0");
+    expectIptablesCommands(startFirstNat);
+
+    std::vector<ExpectedIptablesCommands> startOtherNat = {
+         startNatCommands("usb0", "rmnet0"),
+         TWIDDLE_COMMANDS,
+    };
+    mNatCtrl.enableNat("usb0", "rmnet0");
+    expectIptablesCommands(startOtherNat);
+
+    ExpectedIptablesCommands stopOtherNat = stopNatCommands("wlan0", "rmnet0");
+    mNatCtrl.disableNat("wlan0", "rmnet0");
+    expectIptablesCommands(stopOtherNat);
+
+    std::vector<ExpectedIptablesCommands> stopLastNat = {
+        stopNatCommands("usb0", "rmnet0"),
+        FLUSH_COMMANDS,
+    };
+    mNatCtrl.disableNat("usb0", "rmnet0");
+    expectIptablesCommands(stopLastNat);
+}

From 0d036901e25bb63e2ddca7f1bb857af94db364a2 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Tue, 12 Jul 2016 01:19:49 +0900
Subject: [PATCH 08/23] More test coverage for tethering counter parsing.

Bug: 9580643

(cherry picked from commit 750e8fcc77c886636ca22d1624eb16537d731969)

Change-Id: Ia11f374b25d3a9be2168c3e727dd101a80442e8c
---
 server/BandwidthControllerTest.cpp | 48 ++++++++++++++++++++++++++++++++++----
 1 file changed, 43 insertions(+), 5 deletions(-)

diff --git a/server/BandwidthControllerTest.cpp b/server/BandwidthControllerTest.cpp
index 5af9749..9a60402 100644
--- a/server/BandwidthControllerTest.cpp
+++ b/server/BandwidthControllerTest.cpp
@@ -161,6 +161,11 @@ std::string readSocketClientResponse(int fd) {
     return std::string(buf, bytesRead);
 }
 
+void expectNoSocketClientResponse(int fd) {
+    char buf[64];
+    EXPECT_EQ(-1, read(fd, buf, sizeof(buf)));
+}
+
 TEST_F(BandwidthControllerTest, TestGetTetherStats) {
     int socketPair[2];
     ASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, socketPair));
@@ -175,25 +180,58 @@ TEST_F(BandwidthControllerTest, TestGetTetherStats) {
             "114 wlan0 rmnet0 2373 26 2002 27\n"
             "114 bt-pan rmnet0 107471 1040 1708806 1450\n"
             "200 Tethering stats list completed\n";
-    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
 
     addPopenContents(kIPv4TetherCounters);
     filter = BandwidthController::TetherStats("bt-pan", "rmnet0", -1, -1, -1, -1);
     expected = "221 bt-pan rmnet0 107471 1040 1708806 1450\n";
-    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
 
-
     addPopenContents(kIPv4TetherCounters);
     filter = BandwidthController::TetherStats("rmnet0", "wlan0", -1, -1, -1, -1);
     expected = "221 rmnet0 wlan0 2002 27 2373 26\n";
-    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
 
     addPopenContents(kIPv4TetherCounters);
     filter = BandwidthController::TetherStats("rmnet0", "foo0", -1, -1, -1, -1);
     expected = "200 Tethering stats list completed\n";
-    mBw.getTetherStats(&cli, filter, err);
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
+    ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+
+    // No stats with a filter: no error.
+    addPopenContents("");
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
+    ASSERT_EQ("200 Tethering stats list completed\n", readSocketClientResponse(socketPair[1]));
+    addPopenContents("foo");
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
+    ASSERT_EQ("200 Tethering stats list completed\n", readSocketClientResponse(socketPair[1]));
+
+    // No stats and empty filter: error.
+    filter = BandwidthController::TetherStats();
+    addPopenContents("");
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    addPopenContents("foo");
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    expectNoSocketClientResponse(socketPair[1]);
+
+    // Include only one pair of interfaces and things are fine.
+    std::vector<std::string> counterLines = android::base::Split(kIPv4TetherCounters, "\n");
+    std::vector<std::string> brokenCounterLines = counterLines;
+    counterLines.resize(4);
+    std::string counters = android::base::Join(counterLines, "\n") + "\n";
+    addPopenContents(counters);
+    expected =
+            "114 wlan0 rmnet0 2373 26 2002 27\n"
+            "200 Tethering stats list completed\n";
+    ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+
+    // But if interfaces aren't paired, it's always an error.
+    counterLines.resize(3);
+    counters = android::base::Join(counterLines, "\n") + "\n";
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    expectNoSocketClientResponse(socketPair[1]);
 }

From 4a0b98ac9709d5ab6433e8ff7cec945aa0f2856c Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Fri, 8 Jul 2016 18:24:53 +0900
Subject: [PATCH 09/23] Refactor getTetherStats in preparation for IPv6 tether
 counters.

Bug: 9580643

(cherry picked from commit 7364b75ca058d34875eb3567a57bfd9c03628129)

Change-Id: I481cb3ce681e9afdce9a26fe6e29ff8343f7d2e2
---
 server/BandwidthController.cpp | 43 +++++++++++++++++++++++++++++++-----------
 server/BandwidthController.h   | 20 ++++++++++++++++++++
 2 files changed, 52 insertions(+), 11 deletions(-)

diff --git a/server/BandwidthController.cpp b/server/BandwidthController.cpp
index f52c087..5596784 100644
--- a/server/BandwidthController.cpp
+++ b/server/BandwidthController.cpp
@@ -1082,6 +1082,16 @@ int BandwidthController::removeCostlyAlert(const char *costName, int64_t *alertB
     return res;
 }
 
+void BandwidthController::addStats(TetherStatsList& statsList, const TetherStats& stats) {
+    for (TetherStats& existing : statsList) {
+        if (existing.addStatsIfMatch(stats)) {
+            return;
+        }
+    }
+    // No match. Insert a new interface pair.
+    statsList.push_back(stats);
+}
+
 /*
  * Parse the ptks and bytes out of:
  *   Chain natctrl_tether_counters (4 references)
@@ -1093,8 +1103,9 @@ int BandwidthController::removeCostlyAlert(const char *costName, int64_t *alertB
  * It results in an error if invoked and no tethering counter rules exist. The constraint
  * helps detect complete parsing failure.
  */
-int BandwidthController::parseForwardChainStats(SocketClient *cli, const TetherStats filter,
-                                                FILE *fp, std::string &extraProcessingInfo) {
+int BandwidthController::addForwardChainStats(const TetherStats& filter,
+                                              TetherStatsList& statsList, FILE *fp,
+                                              std::string &extraProcessingInfo) {
     int res;
     char lineBuffer[MAX_IPT_OUTPUT_LINE_LEN];
     char iface0[MAX_IPT_OUTPUT_LINE_LEN];
@@ -1170,17 +1181,13 @@ int BandwidthController::parseForwardChainStats(SocketClient *cli, const TetherS
         }
         if (stats.rxBytes != -1 && stats.txBytes != -1) {
             ALOGV("rx_bytes=%" PRId64" tx_bytes=%" PRId64" filterPair=%d", stats.rxBytes, stats.txBytes, filterPair);
-            /* Send out stats, and prep for the next if needed. */
-            char *msg = stats.getStatsLine();
+            addStats(statsList, stats);
             if (filterPair) {
-                cli->sendMsg(ResponseCode::TetheringStatsResult, msg, false);
                 return 0;
             } else {
-                cli->sendMsg(ResponseCode::TetheringStatsListResult, msg, false);
+                statsFound++;
                 stats = filter;
             }
-            free(msg);
-            statsFound++;
         }
     }
 
@@ -1190,7 +1197,6 @@ int BandwidthController::parseForwardChainStats(SocketClient *cli, const TetherS
         (!statsFound && !filterPair)) {
         return -1;
     }
-    cli->sendMsg(ResponseCode::CommandOkay, "Tethering stats list completed", false);
     return 0;
 }
 
@@ -1201,11 +1207,14 @@ char *BandwidthController::TetherStats::getStatsLine(void) const {
     return msg;
 }
 
-int BandwidthController::getTetherStats(SocketClient *cli, TetherStats &stats, std::string &extraProcessingInfo) {
+int BandwidthController::getTetherStats(SocketClient *cli, TetherStats& filter,
+                                        std::string &extraProcessingInfo) {
     int res;
     std::string fullCmd;
     FILE *iptOutput;
 
+    TetherStatsList statsList;
+
     /*
      * Why not use some kind of lib to talk to iptables?
      * Because the only libs are libiptc and libip6tc in iptables, and they are
@@ -1222,9 +1231,21 @@ int BandwidthController::getTetherStats(SocketClient *cli, TetherStats &stats, s
             extraProcessingInfo += "Failed to run iptables.";
         return -1;
     }
-    res = parseForwardChainStats(cli, stats, iptOutput, extraProcessingInfo);
+
+    res = addForwardChainStats(filter, statsList, iptOutput, extraProcessingInfo);
     pclose(iptOutput);
 
+    if (filter.intIface[0] && filter.extIface[0] && statsList.size() == 1) {
+        cli->sendMsg(ResponseCode::TetheringStatsResult, statsList[0].getStatsLine(), false);
+    } else {
+        for (const auto& stats: statsList) {
+            cli->sendMsg(ResponseCode::TetheringStatsListResult, stats.getStatsLine(), false);
+        }
+        if (res == 0) {
+            cli->sendMsg(ResponseCode::CommandOkay, "Tethering stats list completed", false);
+        }
+    }
+
     /* Currently NatController doesn't do ipv6 tethering, so we are done. */
     return res;
 }
diff --git a/server/BandwidthController.h b/server/BandwidthController.h
index 5da4fe1..53385d1 100644
--- a/server/BandwidthController.h
+++ b/server/BandwidthController.h
@@ -52,6 +52,17 @@ class BandwidthController {
          * The caller is responsible for free()'ing the returned ptr.
          */
         char *getStatsLine(void) const;
+
+        bool addStatsIfMatch(const TetherStats& other) {
+            if (intIface == other.intIface && extIface == other.extIface) {
+                rxBytes   += other.rxBytes;
+                rxPackets += other.rxPackets;
+                txBytes   += other.txBytes;
+                txPackets += other.txPackets;
+                return true;
+            }
+            return false;
+        }
     };
 
     BandwidthController();
@@ -156,6 +167,15 @@ class BandwidthController {
     int setCostlyAlert(const char *costName, int64_t bytes, int64_t *alertBytes);
     int removeCostlyAlert(const char *costName, int64_t *alertBytes);
 
+    typedef std::vector<TetherStats> TetherStatsList;
+
+    static void addStats(TetherStatsList& statsList, const TetherStats& stats);
+
+    static int addForwardChainStats(const TetherStats& filter,
+                                    TetherStatsList& statsList, FILE *fp,
+                                    std::string &extraProcessingInfo);
+
+
     /*
      * stats should never have only intIface initialized. Other 3 combos are ok.
      * fp should be a file to the apropriate FORWARD chain of iptables rules.

From 7834a58a5d3fc3f7115cd3bc585664f90b20278f Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Sun, 10 Jul 2016 23:15:46 +0900
Subject: [PATCH 10/23] Add counters for IPv6 tethering.

Bug: 9580643

(cherry picked from commit 05cfd25d3f22c71c2c6980d1880c01162d915665)

Change-Id: I706c16afe09adf27664e6c1b88b1756adf6eb678
---
 server/CommandListener.cpp   |  2 +-
 server/NatController.cpp     | 70 ++++++++++++++++++++++++--------------------
 server/NatControllerTest.cpp | 45 +++++++++++++++-------------
 3 files changed, 64 insertions(+), 53 deletions(-)

diff --git a/server/CommandListener.cpp b/server/CommandListener.cpp
index bcca44e..e7bca55 100644
--- a/server/CommandListener.cpp
+++ b/server/CommandListener.cpp
@@ -215,7 +215,7 @@ CommandListener::CommandListener() :
     createChildChains(V4V6, "filter", "OUTPUT", FILTER_OUTPUT);
     createChildChains(V4V6, "raw", "PREROUTING", RAW_PREROUTING);
     createChildChains(V4V6, "mangle", "POSTROUTING", MANGLE_POSTROUTING);
-    createChildChains(V4, "mangle", "FORWARD", MANGLE_FORWARD);
+    createChildChains(V4V6, "mangle", "FORWARD", MANGLE_FORWARD);
     createChildChains(V4, "nat", "PREROUTING", NAT_PREROUTING);
     createChildChains(V4, "nat", "POSTROUTING", NAT_POSTROUTING);
 
diff --git a/server/NatController.cpp b/server/NatController.cpp
index fba96ca..b978358 100644
--- a/server/NatController.cpp
+++ b/server/NatController.cpp
@@ -86,9 +86,17 @@ int NatController::setupIptablesHooks() {
 
     struct CommandsAndArgs defaultCommands[] = {
         /*
-         * First chain is for tethering counters.
+         * This is for tethering counters.
          * This chain is reached via --goto, and then RETURNS.
-         *
+         */
+        {{IPTABLES_PATH, "-w", "-F", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
+        {{IP6TABLES_PATH, "-w", "-F", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
+        {{IPTABLES_PATH, "-w", "-X", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
+        {{IP6TABLES_PATH, "-w", "-X", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
+        {{IPTABLES_PATH, "-w", "-N", LOCAL_TETHER_COUNTERS_CHAIN,}, 1},
+        {{IP6TABLES_PATH, "-w", "-N", LOCAL_TETHER_COUNTERS_CHAIN,}, 1},
+
+        /*
          * Second chain is used to limit downstream mss to the upstream pmtu
          * so we don't end up fragmenting every large packet tethered devices
          * send.  Note this feature requires kernel support with flag
@@ -97,11 +105,8 @@ int NatController::setupIptablesHooks() {
          * Bug 17629786 asks to make the failure more obvious, or even fatal
          * so that all builds eventually gain the performance improvement.
          */
-        {{IPTABLES_PATH, "-w", "-F", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
-        {{IPTABLES_PATH, "-w", "-X", LOCAL_TETHER_COUNTERS_CHAIN,}, 0},
-        {{IPTABLES_PATH, "-w", "-N", LOCAL_TETHER_COUNTERS_CHAIN,}, 1},
-        {{IPTABLES_PATH, "-w", "-t", "mangle", "-A", LOCAL_MANGLE_FORWARD, "-p", "tcp", "--tcp-flags",
-                "SYN", "SYN", "-j", "TCPMSS", "--clamp-mss-to-pmtu"}, 0},
+        {{IPTABLES_PATH, "-w", "-t", "mangle", "-A", LOCAL_MANGLE_FORWARD, "-p", "tcp",
+                "--tcp-flags", "SYN", "SYN", "-j", "TCPMSS", "--clamp-mss-to-pmtu"}, 0},
     };
     for (unsigned int cmdNum = 0; cmdNum < ARRAY_SIZE(defaultCommands); cmdNum++) {
         if (runCmd(ARRAY_SIZE(defaultCommands[cmdNum].cmd), defaultCommands[cmdNum].cmd) &&
@@ -123,6 +128,7 @@ int NatController::setDefaults() {
      */
     struct CommandsAndArgs defaultCommands[] = {
         {{IPTABLES_PATH, "-w", "-F", LOCAL_FORWARD,}, 1},
+        {{IP6TABLES_PATH, "-w", "-F", LOCAL_FORWARD,}, 1},
         {{IPTABLES_PATH, "-w", "-A", LOCAL_FORWARD, "-j", "DROP"}, 1},
         {{IPTABLES_PATH, "-w", "-t", "nat", "-F", LOCAL_NAT_POSTROUTING}, 1},
     };
@@ -155,7 +161,7 @@ int NatController::enableNat(const char* intIface, const char* extIface) {
 
     // add this if we are the first added nat
     if (natCount == 0) {
-        const char *cmd[] = {
+        const char *v4Cmd[] = {
                 IPTABLES_PATH,
                 "-w",
                 "-t",
@@ -167,7 +173,15 @@ int NatController::enableNat(const char* intIface, const char* extIface) {
                 "-j",
                 "MASQUERADE"
         };
-        if (runCmd(ARRAY_SIZE(cmd), cmd)) {
+
+        /*
+         * IPv6 tethering doesn't need the state-based conntrack rules, so
+         * it unconditionally jumps to the tether counters chain all the time.
+         */
+        const char *v6Cmd[] = {IP6TABLES_PATH, "-w", "-A", LOCAL_FORWARD,
+                               "-g", LOCAL_TETHER_COUNTERS_CHAIN};
+
+        if (runCmd(ARRAY_SIZE(v4Cmd), v4Cmd) || runCmd(ARRAY_SIZE(v6Cmd), v6Cmd)) {
             ALOGE("Error setting postroute rule: iface=%s", extIface);
             // unwind what's been done, but don't care about success - what more could we do?
             setDefaults();
@@ -234,19 +248,16 @@ int NatController::setTetherCountingRules(bool add, const char *intIface, const
         return 0;
     }
     const char *cmd2b[] = {
-            IPTABLES_PATH,
-            "-w",
-            "-A",
-            LOCAL_TETHER_COUNTERS_CHAIN,
-            "-i",
-            intIface,
-            "-o",
-            extIface,
-            "-j",
-          "RETURN"
+        IPTABLES_PATH,
+        "-w", "-A", LOCAL_TETHER_COUNTERS_CHAIN, "-i", intIface, "-o", extIface, "-j", "RETURN"
     };
 
-    if (runCmd(ARRAY_SIZE(cmd2b), cmd2b) && add) {
+    const char *cmd2c[] = {
+        IP6TABLES_PATH,
+        "-w", "-A", LOCAL_TETHER_COUNTERS_CHAIN, "-i", intIface, "-o", extIface, "-j", "RETURN"
+    };
+
+    if (runCmd(ARRAY_SIZE(cmd2b), cmd2b) || runCmd(ARRAY_SIZE(cmd2c), cmd2c)) {
         free(pair_name);
         return -1;
     }
@@ -260,19 +271,16 @@ int NatController::setTetherCountingRules(bool add, const char *intIface, const
     }
 
     const char *cmd3b[] = {
-            IPTABLES_PATH,
-            "-w",
-            "-A",
-            LOCAL_TETHER_COUNTERS_CHAIN,
-            "-i",
-            extIface,
-            "-o",
-            intIface,
-            "-j",
-            "RETURN"
+        IPTABLES_PATH,
+        "-w", "-A", LOCAL_TETHER_COUNTERS_CHAIN, "-i", extIface, "-o", intIface, "-j", "RETURN"
+    };
+
+    const char *cmd3c[] = {
+        IP6TABLES_PATH,
+        "-w", "-A", LOCAL_TETHER_COUNTERS_CHAIN, "-i", extIface, "-o", intIface, "-j", "RETURN"
     };
 
-    if (runCmd(ARRAY_SIZE(cmd3b), cmd3b) && add) {
+    if (runCmd(ARRAY_SIZE(cmd3b), cmd3b) || runCmd(ARRAY_SIZE(cmd3c), cmd3c)) {
         // unwind what's been done, but don't care about success - what more could we do?
         free(pair_name);
         return -1;
diff --git a/server/NatControllerTest.cpp b/server/NatControllerTest.cpp
index 551efc6..e6c7b47 100644
--- a/server/NatControllerTest.cpp
+++ b/server/NatControllerTest.cpp
@@ -48,20 +48,20 @@ class NatControllerTest : public IptablesBaseTest {
     }
 
     const ExpectedIptablesCommands FLUSH_COMMANDS = {
-        { V4, "-F natctrl_FORWARD" },
-        { V4, "-A natctrl_FORWARD -j DROP" },
-        { V4, "-t nat -F natctrl_nat_POSTROUTING" },
+        { V4V6, "-F natctrl_FORWARD" },
+        { V4,   "-A natctrl_FORWARD -j DROP" },
+        { V4,   "-t nat -F natctrl_nat_POSTROUTING" },
     };
 
     const ExpectedIptablesCommands SETUP_COMMANDS = {
-        { V4, "-F natctrl_FORWARD" },
-        { V4, "-A natctrl_FORWARD -j DROP" },
-        { V4, "-t nat -F natctrl_nat_POSTROUTING" },
-        { V4, "-F natctrl_tether_counters" },
-        { V4, "-X natctrl_tether_counters" },
-        { V4, "-N natctrl_tether_counters" },
-        { V4, "-t mangle -A natctrl_mangle_FORWARD -p tcp --tcp-flags SYN SYN "
-              "-j TCPMSS --clamp-mss-to-pmtu" },
+        { V4V6, "-F natctrl_FORWARD" },
+        { V4,   "-A natctrl_FORWARD -j DROP" },
+        { V4,   "-t nat -F natctrl_nat_POSTROUTING" },
+        { V4V6, "-F natctrl_tether_counters" },
+        { V4V6, "-X natctrl_tether_counters" },
+        { V4V6, "-N natctrl_tether_counters" },
+        { V4,   "-t mangle -A natctrl_mangle_FORWARD -p tcp --tcp-flags SYN SYN "
+                "-j TCPMSS --clamp-mss-to-pmtu" },
     };
 
     const ExpectedIptablesCommands TWIDDLE_COMMANDS = {
@@ -69,22 +69,25 @@ class NatControllerTest : public IptablesBaseTest {
         { V4, "-A natctrl_FORWARD -j DROP" },
     };
 
-    ExpectedIptablesCommands enableMasqueradeCommand(const char *extIf) {
+    ExpectedIptablesCommands firstNatCommands(const char *extIf) {
         return {
             { V4, StringPrintf("-t nat -A natctrl_nat_POSTROUTING -o %s -j MASQUERADE", extIf) },
+            { V6, "-A natctrl_FORWARD -g natctrl_tether_counters" },
         };
     }
 
     ExpectedIptablesCommands startNatCommands(const char *intIf, const char *extIf) {
         return {
-            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state"
-                               " ESTABLISHED,RELATED -g natctrl_tether_counters", extIf, intIf) },
-            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state INVALID -j DROP",
-                               intIf, extIf) },
-            { V4, StringPrintf("-A natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
-                               intIf, extIf) },
-            { V4, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN", intIf, extIf) },
-            { V4, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN", extIf, intIf) },
+            { V4,   StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state"
+                                 " ESTABLISHED,RELATED -g natctrl_tether_counters", extIf, intIf) },
+            { V4,   StringPrintf("-A natctrl_FORWARD -i %s -o %s -m state --state INVALID -j DROP",
+                                 intIf, extIf) },
+            { V4,   StringPrintf("-A natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
+                                 intIf, extIf) },
+            { V4V6, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN",
+                                 intIf, extIf) },
+            { V4V6, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN",
+                                 extIf, intIf) },
         };
     }
 
@@ -113,7 +116,7 @@ TEST_F(NatControllerTest, TestSetDefaults) {
 TEST_F(NatControllerTest, TestAddAndRemoveNat) {
 
     std::vector<ExpectedIptablesCommands> startFirstNat = {
-        enableMasqueradeCommand("rmnet0"),
+        firstNatCommands("rmnet0"),
         startNatCommands("wlan0", "rmnet0"),
         TWIDDLE_COMMANDS,
     };

From 9e190a24e4df0311168ed863af01eccd2a103480 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Mon, 11 Jul 2016 11:36:25 +0900
Subject: [PATCH 11/23] Parse IPv6 tethering counters.

Bug: 9580643

(cherry picked from commit 26c9132b8b5993f8edbb999696e18fa6469d6759)

Change-Id: I62f4120dfd59442e4602e5d46d4d3f4e50b30d7e
---
 server/BandwidthController.cpp     | 66 ++++++++++++++++++++----------
 server/BandwidthControllerTest.cpp | 83 ++++++++++++++++++++++++++++++++------
 2 files changed, 114 insertions(+), 35 deletions(-)

diff --git a/server/BandwidthController.cpp b/server/BandwidthController.cpp
index 5596784..09dc483 100644
--- a/server/BandwidthController.cpp
+++ b/server/BandwidthController.cpp
@@ -1100,6 +1100,12 @@ void BandwidthController::addStats(TetherStatsList& statsList, const TetherStats
  *         27     2002 RETURN     all  --  rmnet0 wlan0   0.0.0.0/0            0.0.0.0/0
  *       1040   107471 RETURN     all  --  bt-pan rmnet0  0.0.0.0/0            0.0.0.0/0
  *       1450  1708806 RETURN     all  --  rmnet0 bt-pan  0.0.0.0/0            0.0.0.0/0
+ * or:
+ *   Chain natctrl_tether_counters (0 references)
+ *       pkts      bytes target     prot opt in     out     source               destination
+ *          0        0 RETURN     all      wlan0  rmnet_data0  ::/0                 ::/0
+ *          0        0 RETURN     all      rmnet_data0 wlan0   ::/0                 ::/0
+ *
  * It results in an error if invoked and no tethering counter rules exist. The constraint
  * helps detect complete parsing failure.
  */
@@ -1128,8 +1134,17 @@ int BandwidthController::addForwardChainStats(const TetherStats& filter,
     while (NULL != (buffPtr = fgets(lineBuffer, MAX_IPT_OUTPUT_LINE_LEN, fp))) {
         /* Clean up, so a failed parse can still print info */
         iface0[0] = iface1[0] = rest[0] = packets = bytes = 0;
-        res = sscanf(buffPtr, "%" SCNd64" %" SCNd64" RETURN all -- %s %s 0.%s",
-                &packets, &bytes, iface0, iface1, rest);
+        if (strstr(buffPtr, "0.0.0.0")) {
+            // IPv4 has -- indicating what to do with fragments...
+            //       26     2373 RETURN     all  --  wlan0  rmnet0  0.0.0.0/0            0.0.0.0/0
+            res = sscanf(buffPtr, "%" SCNd64" %" SCNd64" RETURN all -- %s %s 0.%s",
+                    &packets, &bytes, iface0, iface1, rest);
+        } else {
+            // ... but IPv6 does not.
+            //       26     2373 RETURN     all      wlan0  rmnet0  ::/0                 ::/0
+            res = sscanf(buffPtr, "%" SCNd64" %" SCNd64" RETURN all %s %s ::/%s",
+                    &packets, &bytes, iface0, iface1, rest);
+        }
         ALOGV("parse res=%d iface0=<%s> iface1=<%s> pkts=%" PRId64" bytes=%" PRId64" rest=<%s> orig line=<%s>", res,
              iface0, iface1, packets, bytes, rest, buffPtr);
         extraProcessingInfo += buffPtr;
@@ -1207,14 +1222,7 @@ char *BandwidthController::TetherStats::getStatsLine(void) const {
     return msg;
 }
 
-int BandwidthController::getTetherStats(SocketClient *cli, TetherStats& filter,
-                                        std::string &extraProcessingInfo) {
-    int res;
-    std::string fullCmd;
-    FILE *iptOutput;
-
-    TetherStatsList statsList;
-
+std::string getTetherStatsCommand(const char *binary) {
     /*
      * Why not use some kind of lib to talk to iptables?
      * Because the only libs are libiptc and libip6tc in iptables, and they are
@@ -1222,18 +1230,33 @@ int BandwidthController::getTetherStats(SocketClient *cli, TetherStats& filter,
      * preloaded/linked, and require apparently a lot of wrapper code to get
      * the wanted info.
      */
-    fullCmd = IPTABLES_PATH;
-    fullCmd += " -nvx -w -L ";
-    fullCmd += NatController::LOCAL_TETHER_COUNTERS_CHAIN;
-    iptOutput = popenFunction(fullCmd.c_str(), "r");
-    if (!iptOutput) {
-            ALOGE("Failed to run %s err=%s", fullCmd.c_str(), strerror(errno));
-            extraProcessingInfo += "Failed to run iptables.";
-        return -1;
-    }
+    return android::base::StringPrintf("%s -nvx -w -L %s", binary,
+                                       NatController::LOCAL_TETHER_COUNTERS_CHAIN);
+}
 
-    res = addForwardChainStats(filter, statsList, iptOutput, extraProcessingInfo);
-    pclose(iptOutput);
+int BandwidthController::getTetherStats(SocketClient *cli, TetherStats& filter,
+                                        std::string &extraProcessingInfo) {
+    int res = 0;
+    std::string fullCmd;
+    FILE *iptOutput;
+
+    TetherStatsList statsList;
+
+    for (const auto binary : {IPTABLES_PATH, IP6TABLES_PATH}) {
+        fullCmd = getTetherStatsCommand(binary);
+        iptOutput = popenFunction(fullCmd.c_str(), "r");
+        if (!iptOutput) {
+                ALOGE("Failed to run %s err=%s", fullCmd.c_str(), strerror(errno));
+                extraProcessingInfo += "Failed to run iptables.";
+            return -1;
+        }
+
+        res = addForwardChainStats(filter, statsList, iptOutput, extraProcessingInfo);
+        pclose(iptOutput);
+        if (res != 0) {
+            return res;
+        }
+    }
 
     if (filter.intIface[0] && filter.extIface[0] && statsList.size() == 1) {
         cli->sendMsg(ResponseCode::TetheringStatsResult, statsList[0].getStatsLine(), false);
@@ -1246,7 +1269,6 @@ int BandwidthController::getTetherStats(SocketClient *cli, TetherStats& filter,
         }
     }
 
-    /* Currently NatController doesn't do ipv6 tethering, so we are done. */
     return res;
 }
 
diff --git a/server/BandwidthControllerTest.cpp b/server/BandwidthControllerTest.cpp
index 9a60402..3e11596 100644
--- a/server/BandwidthControllerTest.cpp
+++ b/server/BandwidthControllerTest.cpp
@@ -43,6 +43,15 @@ class BandwidthControllerTest : public IptablesBaseTest {
     void addPopenContents(std::string contents) {
         sPopenContents.push_back(contents);
     }
+
+    void addPopenContents(std::string contents1, std::string contents2) {
+        sPopenContents.push_back(contents1);
+        sPopenContents.push_back(contents2);
+    }
+
+    void clearPopenContents() {
+        sPopenContents.clear();
+    }
 };
 
 TEST_F(BandwidthControllerTest, TestSetupIptablesHooks) {
@@ -149,6 +158,13 @@ std::string kIPv4TetherCounters = android::base::Join(std::vector<std::string> {
     "    1450  1708806 RETURN     all  --  rmnet0 bt-pan  0.0.0.0/0            0.0.0.0/0",
 }, '\n');
 
+std::string kIPv6TetherCounters = android::base::Join(std::vector<std::string> {
+    "Chain natctrl_tether_counters (2 references)",
+    "    pkts      bytes target     prot opt in     out     source               destination",
+    "   10000 10000000 RETURN     all      wlan0  rmnet0  ::/0                 ::/0",
+    "   20000 20000000 RETURN     all      rmnet0 wlan0   ::/0                 ::/0",
+}, '\n');
+
 std::string readSocketClientResponse(int fd) {
     char buf[32768];
     ssize_t bytesRead = read(fd, buf, sizeof(buf));
@@ -175,63 +191,104 @@ TEST_F(BandwidthControllerTest, TestGetTetherStats) {
 
     std::string err;
     BandwidthController::TetherStats filter;
-    addPopenContents(kIPv4TetherCounters);
+
+    // If no filter is specified, both IPv4 and IPv6 counters must have at least one interface pair.
+    addPopenContents(kIPv4TetherCounters, "");
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
+
+    addPopenContents("", kIPv6TetherCounters);
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    clearPopenContents();
+
+    // IPv4 and IPv6 counters are properly added together.
+    addPopenContents(kIPv4TetherCounters, kIPv6TetherCounters);
+    filter = BandwidthController::TetherStats();
     std::string expected =
-            "114 wlan0 rmnet0 2373 26 2002 27\n"
+            "114 wlan0 rmnet0 10002373 10026 20002002 20027\n"
             "114 bt-pan rmnet0 107471 1040 1708806 1450\n"
             "200 Tethering stats list completed\n";
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
 
-    addPopenContents(kIPv4TetherCounters);
+    // Test filtering.
+    addPopenContents(kIPv4TetherCounters, kIPv6TetherCounters);
     filter = BandwidthController::TetherStats("bt-pan", "rmnet0", -1, -1, -1, -1);
     expected = "221 bt-pan rmnet0 107471 1040 1708806 1450\n";
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
 
-    addPopenContents(kIPv4TetherCounters);
-    filter = BandwidthController::TetherStats("rmnet0", "wlan0", -1, -1, -1, -1);
-    expected = "221 rmnet0 wlan0 2002 27 2373 26\n";
+    addPopenContents(kIPv4TetherCounters, kIPv6TetherCounters);
+    filter = BandwidthController::TetherStats("wlan0", "rmnet0", -1, -1, -1, -1);
+    expected = "221 wlan0 rmnet0 10002373 10026 20002002 20027\n";
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+    clearPopenContents();
 
-    addPopenContents(kIPv4TetherCounters);
+    // Select nonexistent interfaces.
+    addPopenContents(kIPv4TetherCounters, kIPv6TetherCounters);
     filter = BandwidthController::TetherStats("rmnet0", "foo0", -1, -1, -1, -1);
     expected = "200 Tethering stats list completed\n";
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+    clearPopenContents();
 
     // No stats with a filter: no error.
-    addPopenContents("");
+    addPopenContents("", "");
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ("200 Tethering stats list completed\n", readSocketClientResponse(socketPair[1]));
-    addPopenContents("foo");
+    clearPopenContents();
+
+    addPopenContents("foo", "foo");
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ("200 Tethering stats list completed\n", readSocketClientResponse(socketPair[1]));
+    clearPopenContents();
 
     // No stats and empty filter: error.
     filter = BandwidthController::TetherStats();
-    addPopenContents("");
+    addPopenContents("", kIPv6TetherCounters);
     ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
-    addPopenContents("foo");
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
+
+    addPopenContents(kIPv4TetherCounters, "");
     ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
     expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
 
     // Include only one pair of interfaces and things are fine.
     std::vector<std::string> counterLines = android::base::Split(kIPv4TetherCounters, "\n");
     std::vector<std::string> brokenCounterLines = counterLines;
     counterLines.resize(4);
     std::string counters = android::base::Join(counterLines, "\n") + "\n";
-    addPopenContents(counters);
+    addPopenContents(counters, counters);
     expected =
-            "114 wlan0 rmnet0 2373 26 2002 27\n"
+            "114 wlan0 rmnet0 4746 52 4004 54\n"
             "200 Tethering stats list completed\n";
     ASSERT_EQ(0, mBw.getTetherStats(&cli, filter, err));
     ASSERT_EQ(expected, readSocketClientResponse(socketPair[1]));
+    clearPopenContents();
 
     // But if interfaces aren't paired, it's always an error.
     counterLines.resize(3);
     counters = android::base::Join(counterLines, "\n") + "\n";
+    addPopenContents(counters, counters);
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
+
+    // popen() failing is always an error.
+    addPopenContents(kIPv4TetherCounters);
+    ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
+    expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
+    addPopenContents(kIPv6TetherCounters);
     ASSERT_EQ(-1, mBw.getTetherStats(&cli, filter, err));
     expectNoSocketClientResponse(socketPair[1]);
+    clearPopenContents();
 }

From f48e4dd80eb164394a8119abc59a5b9ecf36c4db Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Mon, 18 Jul 2016 04:02:07 +0900
Subject: [PATCH 12/23] Add tetherApplyDnsInterfaces() binder interface.

Bug: 9580643

(cherry picked from commit 212c405c296ed869eda927e683734aff80248872)

Change-Id: I0f636266bbaa8c39847ea1e0ffbfdea789b3de53
---
 server/NetdNativeService.cpp         |  7 +++++++
 server/NetdNativeService.h           |  3 +++
 server/TetherController.h            |  2 +-
 server/binder/android/net/INetd.aidl | 10 ++++++++++
 4 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/server/NetdNativeService.cpp b/server/NetdNativeService.cpp
index 5ee8202..10629ef 100644
--- a/server/NetdNativeService.cpp
+++ b/server/NetdNativeService.cpp
@@ -201,5 +201,12 @@ binder::Status NetdNativeService::getResolverInfo(int32_t netId,
     return binder::Status::ok();
 }
 
+binder::Status NetdNativeService::tetherApplyDnsInterfaces(bool *ret) {
+    NETD_BIG_LOCK_RPC(CONNECTIVITY_INTERNAL);
+
+    *ret = gCtls->tetherCtrl.applyDnsInterfaces();
+    return binder::Status::ok();
+}
+
 }  // namespace net
 }  // namespace android
diff --git a/server/NetdNativeService.h b/server/NetdNativeService.h
index b5c8f69..c5d9114 100644
--- a/server/NetdNativeService.h
+++ b/server/NetdNativeService.h
@@ -47,6 +47,9 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
     binder::Status getResolverInfo(int32_t netId, std::vector<std::string>* servers,
             std::vector<std::string>* domains, std::vector<int32_t>* params,
             std::vector<int32_t>* stats) override;
+
+    // Tethering-related commands.
+    binder::Status tetherApplyDnsInterfaces(bool *ret) override;
 };
 
 }  // namespace net
diff --git a/server/TetherController.h b/server/TetherController.h
index 6035c25..3769890 100644
--- a/server/TetherController.h
+++ b/server/TetherController.h
@@ -54,9 +54,9 @@ class TetherController {
     int tetherInterface(const char *interface);
     int untetherInterface(const char *interface);
     const std::list<std::string> &getTetheredInterfaceList() const;
+    bool applyDnsInterfaces();
 
 private:
-    bool applyDnsInterfaces();
     bool setIpFwdEnabled();
 };
 
diff --git a/server/binder/android/net/INetd.aidl b/server/binder/android/net/INetd.aidl
index 097f98a..1b901b8 100644
--- a/server/binder/android/net/INetd.aidl
+++ b/server/binder/android/net/INetd.aidl
@@ -145,4 +145,14 @@ interface INetd {
      */
     void getResolverInfo(int netId, out @utf8InCpp String[] servers,
             out @utf8InCpp String[] domains, out int[] params, out int[] stats);
+
+    /**
+     * Instruct the tethering DNS server to reevaluated serving interfaces.
+     * This is needed to for the DNS server to observe changes in the set
+     * of potential listening IP addresses. (Listening on wildcard addresses
+     * can turn the device into an open resolver; b/7530468)
+     *
+     * TODO: Return something richer than just a boolean.
+     */
+    boolean tetherApplyDnsInterfaces();
 }

From 755faa9dae1fbe7cead43702a05fe2821c1573d3 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Wed, 27 Jul 2016 22:10:49 +0900
Subject: [PATCH 13/23] Make the socketDestroy tests use a fake tun interface.

On real devices, we often don't want to destroy sockets that
are on loopback. This CL makes our integration tests use
sockets that don't look like they're on loopback, making it
possible to test code that does not destroy sockets that are
on loopback.

Bug: 30186506

(cherry picked from commit 549a0f705849d0a1dcf9de38cbe54edad4a83cd9)

Change-Id: Ic4b8a7cb684010576f0c9c40a037906c7ba4d93d
---
 tests/Android.mk      |  3 +-
 tests/binder_test.cpp | 83 +++++++++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 80 insertions(+), 6 deletions(-)

diff --git a/tests/Android.mk b/tests/Android.mk
index 6a6b6da..b4a2ccd 100644
--- a/tests/Android.mk
+++ b/tests/Android.mk
@@ -24,11 +24,12 @@ LOCAL_CFLAGS += -Wno-varargs
 
 EXTRA_LDLIBS := -lpthread
 LOCAL_SHARED_LIBRARIES += libbase libbinder libcutils liblog liblogwrap libnetdaidl libnetd_client \
-                          libutils
+                          libnetutils libutils
 LOCAL_STATIC_LIBRARIES += libtestUtil
 LOCAL_AIDL_INCLUDES := system/netd/server/binder
 LOCAL_C_INCLUDES += system/netd/include system/extras/tests/include system/netd/binder/include \
                     system/netd/server system/core/logwrapper/include \
+                    system/core/libnetutils/include \
                     system/extras/tests/include bionic/libc/dns/include
 # netd_integration_test.cpp is currently empty and exists only so that we can do:
 # runtest -x system/netd/tests/netd_integration_test.cpp
diff --git a/tests/binder_test.cpp b/tests/binder_test.cpp
index 42d01a5..0fe6d5f 100644
--- a/tests/binder_test.cpp
+++ b/tests/binder_test.cpp
@@ -24,20 +24,28 @@
 #include <set>
 #include <vector>
 
+#include <fcntl.h>
+#include <netdb.h>
 #include <sys/socket.h>
+#include <sys/types.h>
 #include <netinet/in.h>
+#include <linux/if.h>
+#include <linux/if_tun.h>
 
 #include <android-base/stringprintf.h>
 #include <android-base/strings.h>
 #include <cutils/multiuser.h>
 #include <gtest/gtest.h>
 #include <logwrap/logwrap.h>
+#include <netutils/ifc.h>
 
 #include "NetdConstants.h"
 #include "android/net/INetd.h"
 #include "android/net/UidRange.h"
 #include "binder/IServiceManager.h"
 
+#define TUN_DEV "/dev/tun"
+
 using namespace android;
 using namespace android::base;
 using namespace android::binder;
@@ -58,14 +66,36 @@ class BinderTest : public ::testing::Test {
         }
     }
 
-    void SetUp() {
+    void SetUp() override {
         ASSERT_NE(nullptr, mNetd.get());
     }
 
+    // Static because setting up the tun interface takes about 40ms.
+    static void SetUpTestCase() {
+        sTunFd = createTunInterface();
+        ASSERT_NE(-1, sTunFd);
+    }
+
+    static void TearDownTestCase() {
+        // Closing the socket removes the interface and IP addresses.
+        close(sTunFd);
+    }
+
+    static void fakeRemoteSocketPair(int *clientSocket, int *serverSocket, int *acceptedSocket);
+    static int createTunInterface();
+
 protected:
     sp<INetd> mNetd;
+    static int sTunFd;
+    static in6_addr sSrcAddr, sDstAddr;
+    static char sSrcStr[], sDstStr[];
 };
 
+int BinderTest::sTunFd;
+in6_addr BinderTest::sSrcAddr;
+in6_addr BinderTest::sDstAddr;
+char BinderTest::sSrcStr[INET6_ADDRSTRLEN];
+char BinderTest::sDstStr[INET6_ADDRSTRLEN];
 
 class TimedOperation : public Stopwatch {
 public:
@@ -296,9 +326,51 @@ TEST_F(BinderTest, TestNetworkRejectNonSecureVpn) {
     EXPECT_EQ(initialRulesV6, listIpRules(IP_RULE_V6));
 }
 
-void socketpair(int *clientSocket, int *serverSocket, int *acceptedSocket) {
+int BinderTest::createTunInterface() {
+    // Generate a random ULA address pair.
+    arc4random_buf(&sSrcAddr, sizeof(sSrcAddr));
+    sSrcAddr.s6_addr[0] = 0xfd;
+    memcpy(&sDstAddr, &sSrcAddr, sizeof(sDstAddr));
+    sDstAddr.s6_addr[15] ^= 1;
+
+    // Convert the addresses to strings because that's what ifc_add_address takes.
+    sockaddr_in6 src6 = { .sin6_family = AF_INET6, .sin6_addr = sSrcAddr, };
+    sockaddr_in6 dst6 = { .sin6_family = AF_INET6, .sin6_addr = sDstAddr, };
+    int flags = NI_NUMERICHOST;
+    if (getnameinfo((sockaddr *) &src6, sizeof(src6), sSrcStr, sizeof(sSrcStr), NULL, 0, flags) ||
+        getnameinfo((sockaddr *) &dst6, sizeof(dst6), sDstStr, sizeof(sDstStr), NULL, 0, flags)) {
+        return -1;
+    }
+
+    // Create a tun interface with a name based on our PID.
+    struct ifreq ifr = {
+        .ifr_ifru = { .ifru_flags = IFF_TUN },
+    };
+    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "netdtest%u", getpid());
+
+    int fd = open(TUN_DEV, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+    EXPECT_NE(-1, fd) << TUN_DEV << ": " << strerror(errno);
+    if (fd == -1) return fd;
+
+    int ret = ioctl(fd, TUNSETIFF, &ifr, sizeof(ifr));
+    EXPECT_EQ(0, ret) << "TUNSETIFF: " << strerror(errno);
+    if (ret) {
+        close(fd);
+        return -1;
+    }
+
+    if (ifc_add_address(ifr.ifr_name, sSrcStr, 64) ||
+        ifc_add_address(ifr.ifr_name, sDstStr, 64)) {
+        close(fd);
+        return -1;
+    }
+    return fd;
+}
+
+// Create a socket pair that isLoopbackSocket won't think is local.
+void BinderTest::fakeRemoteSocketPair(int *clientSocket, int *serverSocket, int *acceptedSocket) {
     *serverSocket = socket(AF_INET6, SOCK_STREAM, 0);
-    struct sockaddr_in6 server6 = { .sin6_family = AF_INET6 };
+    struct sockaddr_in6 server6 = { .sin6_family = AF_INET6, .sin6_addr = sDstAddr };
     ASSERT_EQ(0, bind(*serverSocket, (struct sockaddr *) &server6, sizeof(server6)));
 
     socklen_t addrlen = sizeof(server6);
@@ -306,7 +378,8 @@ void socketpair(int *clientSocket, int *serverSocket, int *acceptedSocket) {
     ASSERT_EQ(0, listen(*serverSocket, 10));
 
     *clientSocket = socket(AF_INET6, SOCK_STREAM, 0);
-    struct sockaddr_in6 client6;
+    struct sockaddr_in6 client6 = { .sin6_family = AF_INET6, .sin6_addr = sSrcAddr };
+    ASSERT_EQ(0, bind(*clientSocket, (struct sockaddr *) &client6, sizeof(client6)));
     ASSERT_EQ(0, connect(*clientSocket, (struct sockaddr *) &server6, sizeof(server6)));
     ASSERT_EQ(0, getsockname(*clientSocket, (struct sockaddr *) &client6, &addrlen));
 
@@ -339,7 +412,7 @@ void checkSocketpairClosed(int clientSocket, int acceptedSocket) {
 
 TEST_F(BinderTest, TestSocketDestroy) {
     int clientSocket, serverSocket, acceptedSocket;
-    ASSERT_NO_FATAL_FAILURE(socketpair(&clientSocket, &serverSocket, &acceptedSocket));
+    ASSERT_NO_FATAL_FAILURE(fakeRemoteSocketPair(&clientSocket, &serverSocket, &acceptedSocket));
 
     // Pick a random UID in the system UID range.
     constexpr int baseUid = AID_APP - 2000;

From e5c3c9971a5d1525380c18fff65c2816eb79923e Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Tue, 26 Jul 2016 17:53:50 +0900
Subject: [PATCH 14/23] Don't close loopback sockets when a VPN connects or
 entering doze.

Bug: 30186506

(cherry picked from commit 0726fec82842883a2332318aa675f7f04670db51)

Change-Id: I269d9d9dc2f036b7b65e14577c5525d9cab426ba
---
 server/NetdNativeService.cpp |   3 +-
 server/SockDiag.cpp          |  36 +++++++++++--
 server/SockDiag.h            |  10 +++-
 server/SockDiagTest.cpp      | 124 +++++++++++++++++++++++++++++++++++++++++--
 server/VirtualNetwork.cpp    |   2 +-
 5 files changed, 161 insertions(+), 14 deletions(-)

diff --git a/server/NetdNativeService.cpp b/server/NetdNativeService.cpp
index 10629ef..5e5b8fd 100644
--- a/server/NetdNativeService.cpp
+++ b/server/NetdNativeService.cpp
@@ -164,7 +164,8 @@ binder::Status NetdNativeService::socketDestroy(const std::vector<UidRange>& uid
     }
 
     UidRanges uidRanges(uids);
-    int err = sd.destroySockets(uidRanges, std::set<uid_t>(skipUids.begin(), skipUids.end()));
+    int err = sd.destroySockets(uidRanges, std::set<uid_t>(skipUids.begin(), skipUids.end()),
+                                true /* excludeLoopback */);
 
     if (err) {
         return binder::Status::fromServiceSpecificError(-err,
diff --git a/server/SockDiag.cpp b/server/SockDiag.cpp
index b37455a..6b93a97 100644
--- a/server/SockDiag.cpp
+++ b/server/SockDiag.cpp
@@ -236,6 +236,28 @@ int SockDiag::readDiagMsg(uint8_t proto, const SockDiag::DumpCallback& callback)
     return 0;
 }
 
+// Determines whether a socket is a loopback socket. Does not check socket state.
+bool SockDiag::isLoopbackSocket(const inet_diag_msg *msg) {
+    switch (msg->idiag_family) {
+        case AF_INET:
+            // Old kernels only copy the IPv4 address and leave the other 12 bytes uninitialized.
+            return IN_LOOPBACK(htonl(msg->id.idiag_src[0])) ||
+                   IN_LOOPBACK(htonl(msg->id.idiag_dst[0])) ||
+                   msg->id.idiag_src[0] == msg->id.idiag_dst[0];
+
+        case AF_INET6: {
+            const struct in6_addr *src = (const struct in6_addr *) &msg->id.idiag_src;
+            const struct in6_addr *dst = (const struct in6_addr *) &msg->id.idiag_dst;
+            return (IN6_IS_ADDR_V4MAPPED(src) && IN_LOOPBACK(src->s6_addr32[3])) ||
+                   (IN6_IS_ADDR_V4MAPPED(dst) && IN_LOOPBACK(dst->s6_addr32[3])) ||
+                   IN6_IS_ADDR_LOOPBACK(src) || IN6_IS_ADDR_LOOPBACK(dst) ||
+                   !memcmp(src, dst, sizeof(*src));
+        }
+        default:
+            return false;
+    }
+}
+
 int SockDiag::sockDestroy(uint8_t proto, const inet_diag_msg *msg) {
     if (msg == nullptr) {
        return 0;
@@ -319,12 +341,14 @@ int SockDiag::destroyLiveSockets(DumpCallback destroyFilter) {
     return 0;
 }
 
-int SockDiag::destroySockets(uint8_t proto, const uid_t uid) {
+int SockDiag::destroySockets(uint8_t proto, const uid_t uid, bool excludeLoopback) {
     mSocketsDestroyed = 0;
     Stopwatch s;
 
-    auto shouldDestroy = [uid] (uint8_t, const inet_diag_msg *msg) {
-        return (msg != nullptr && msg->idiag_uid == uid);
+    auto shouldDestroy = [uid, excludeLoopback] (uint8_t, const inet_diag_msg *msg) {
+        return msg != nullptr &&
+               msg->idiag_uid == uid &&
+               !(excludeLoopback && isLoopbackSocket(msg));
     };
 
     for (const int family : {AF_INET, AF_INET6}) {
@@ -347,14 +371,16 @@ int SockDiag::destroySockets(uint8_t proto, const uid_t uid) {
     return 0;
 }
 
-int SockDiag::destroySockets(const UidRanges& uidRanges, const std::set<uid_t>& skipUids) {
+int SockDiag::destroySockets(const UidRanges& uidRanges, const std::set<uid_t>& skipUids,
+                             bool excludeLoopback) {
     mSocketsDestroyed = 0;
     Stopwatch s;
 
     auto shouldDestroy = [&] (uint8_t, const inet_diag_msg *msg) {
         return msg != nullptr &&
                uidRanges.hasUid(msg->idiag_uid) &&
-               skipUids.find(msg->idiag_uid) == skipUids.end();
+               skipUids.find(msg->idiag_uid) == skipUids.end() &&
+               !(excludeLoopback && isLoopbackSocket(msg));
     };
 
     if (int ret = destroyLiveSockets(shouldDestroy)) {
diff --git a/server/SockDiag.h b/server/SockDiag.h
index 278b957..e397793 100644
--- a/server/SockDiag.h
+++ b/server/SockDiag.h
@@ -51,11 +51,16 @@ class SockDiag {
     int sendDumpRequest(uint8_t proto, uint8_t family, const char *addrstr);
     int readDiagMsg(uint8_t proto, const DumpCallback& callback);
     int sockDestroy(uint8_t proto, const inet_diag_msg *);
+    // Destroys all sockets on the given IPv4 or IPv6 address.
     int destroySockets(const char *addrstr);
-    int destroySockets(uint8_t proto, uid_t uid);
-    int destroySockets(const UidRanges& uidRanges, const std::set<uid_t>& skipUids);
+    // Destroys all sockets for the given protocol and UID.
+    int destroySockets(uint8_t proto, uid_t uid, bool excludeLoopback);
+    // Destroys all "live" (CONNECTED, SYN_SENT, SYN_RECV) TCP sockets for the given UID ranges.
+    int destroySockets(const UidRanges& uidRanges, const std::set<uid_t>& skipUids,
+                       bool excludeLoopback);
 
   private:
+    friend class SockDiagTest;
     int mSock;
     int mWriteSock;
     int mSocketsDestroyed;
@@ -64,4 +69,5 @@ class SockDiag {
     int destroyLiveSockets(DumpCallback destroy);
     bool hasSocks() { return mSock != -1 && mWriteSock != -1; }
     void closeSocks() { close(mSock); close(mWriteSock); mSock = mWriteSock = -1; }
+    static bool isLoopbackSocket(const inet_diag_msg *msg);
 };
diff --git a/server/SockDiagTest.cpp b/server/SockDiagTest.cpp
index 2b1bf02..f9353f3 100644
--- a/server/SockDiagTest.cpp
+++ b/server/SockDiagTest.cpp
@@ -16,8 +16,11 @@
  * sock_diag_test.cpp - unit tests for SockDiag.cpp
  */
 
+#include <sys/socket.h>
+#include <netdb.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
+#include <netinet/tcp.h>
 #include <linux/inet_diag.h>
 
 #include <gtest/gtest.h>
@@ -27,6 +30,10 @@
 #include "UidRanges.h"
 
 class SockDiagTest : public ::testing::Test {
+protected:
+    static bool isLoopbackSocket(const inet_diag_msg *msg) {
+        return SockDiag::isLoopbackSocket(msg);
+    };
 };
 
 uint16_t bindAndListen(int s) {
@@ -110,6 +117,9 @@ TEST_F(SockDiagTest, TestDump) {
                 src, htons(msg->id.idiag_sport),
                 dst, htons(msg->id.idiag_dport),
                 tcpStateName(msg->idiag_state));
+        if (msg->idiag_state == TCP_ESTABLISHED) {
+            EXPECT_TRUE(isLoopbackSocket(msg));
+        }
         return false;
     };
 
@@ -136,6 +146,9 @@ TEST_F(SockDiagTest, TestDump) {
                 src, htons(msg->id.idiag_sport),
                 dst, htons(msg->id.idiag_dport),
                 tcpStateName(msg->idiag_state));
+        if (msg->idiag_state == TCP_ESTABLISHED) {
+            EXPECT_TRUE(isLoopbackSocket(msg));
+        }
         return false;
     };
 
@@ -175,10 +188,96 @@ TEST_F(SockDiagTest, TestDump) {
     close(accepted6);
 }
 
+bool fillDiagAddr(__be32 addr[4], const sockaddr *sa) {
+    switch (sa->sa_family) {
+        case AF_INET: {
+            sockaddr_in *sin = (sockaddr_in *) sa;
+            memcpy(addr, &sin->sin_addr, sizeof(sin->sin_addr));
+            return true;
+        }
+        case AF_INET6: {
+            sockaddr_in6 *sin6 = (sockaddr_in6 *) sa;
+            memcpy(addr, &sin6->sin6_addr, sizeof(sin6->sin6_addr));
+            return true;
+        }
+        default:
+            return false;
+    }
+}
+
+inet_diag_msg makeDiagMessage(__u8 family,  const sockaddr *src, const sockaddr *dst) {
+    inet_diag_msg msg = {
+        .idiag_family = family,
+        .idiag_state = TCP_ESTABLISHED,
+        .idiag_uid = AID_APP + 123,
+        .idiag_inode = 123456789,
+        .id = {
+            .idiag_sport = 1234,
+            .idiag_dport = 4321,
+        }
+    };
+    EXPECT_TRUE(fillDiagAddr(msg.id.idiag_src, src));
+    EXPECT_TRUE(fillDiagAddr(msg.id.idiag_dst, dst));
+    return msg;
+}
+
+inet_diag_msg makeDiagMessage(const char* srcstr, const char* dststr) {
+    addrinfo hints = { .ai_flags = AI_NUMERICHOST }, *src, *dst;
+    EXPECT_EQ(0, getaddrinfo(srcstr, NULL, &hints, &src));
+    EXPECT_EQ(0, getaddrinfo(dststr, NULL, &hints, &dst));
+    EXPECT_EQ(src->ai_addr->sa_family, dst->ai_addr->sa_family);
+    inet_diag_msg msg = makeDiagMessage(src->ai_addr->sa_family, src->ai_addr, dst->ai_addr);
+    freeaddrinfo(src);
+    freeaddrinfo(dst);
+    return msg;
+}
+
+TEST_F(SockDiagTest, TestIsLoopbackSocket) {
+    inet_diag_msg msg;
+
+    msg = makeDiagMessage("127.0.0.1", "127.0.0.1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("::1", "::1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("::1", "::ffff:127.0.0.1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("192.0.2.1", "192.0.2.1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("192.0.2.1", "8.8.8.8");
+    EXPECT_FALSE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("192.0.2.1", "127.0.0.1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("2001:db8::1", "2001:db8::1");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("2001:db8::1", "2001:4860:4860::6464");
+    EXPECT_FALSE(isLoopbackSocket(&msg));
+
+    // While isLoopbackSocket returns true on these sockets, we usually don't want to close them
+    // because they aren't specific to any particular network and thus don't become unusable when
+    // an app's routing changes or its network access is removed.
+    //
+    // This isn't a problem, as anything that calls destroyLiveSockets will skip them because
+    // destroyLiveSockets only enumerates ESTABLISHED, SYN_SENT, and SYN_RECV sockets.
+    msg = makeDiagMessage("127.0.0.1", "0.0.0.0");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+
+    msg = makeDiagMessage("::1", "::");
+    EXPECT_TRUE(isLoopbackSocket(&msg));
+}
+
 enum MicroBenchmarkTestType {
     ADDRESS,
     UID,
+    UID_EXCLUDE_LOOPBACK,
     UIDRANGE,
+    UIDRANGE_EXCLUDE_LOOPBACK,
 };
 
 const char *testTypeName(MicroBenchmarkTestType mode) {
@@ -186,7 +285,9 @@ const char *testTypeName(MicroBenchmarkTestType mode) {
     switch((mode)) {
         TO_STRING_TYPE(ADDRESS);
         TO_STRING_TYPE(UID);
+        TO_STRING_TYPE(UID_EXCLUDE_LOOPBACK);
         TO_STRING_TYPE(UIDRANGE);
+        TO_STRING_TYPE(UIDRANGE_EXCLUDE_LOOPBACK);
     }
 #undef TO_STRING_TYPE
 }
@@ -214,7 +315,9 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
         case ADDRESS:
             return ADDRESS_SOCKETS;
         case UID:
+        case UID_EXCLUDE_LOOPBACK:
         case UIDRANGE:
+        case UIDRANGE_EXCLUDE_LOOPBACK:
             return UID_SOCKETS;
         }
     }
@@ -228,16 +331,21 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
                 EXPECT_LE(0, ret) << ": Failed to destroy sockets on ::1: " << strerror(-ret);
                 break;
             case UID:
-                ret = mSd.destroySockets(IPPROTO_TCP, CLOSE_UID);
+            case UID_EXCLUDE_LOOPBACK: {
+                bool excludeLoopback = (mode == UID_EXCLUDE_LOOPBACK);
+                ret = mSd.destroySockets(IPPROTO_TCP, CLOSE_UID, excludeLoopback);
                 EXPECT_LE(0, ret) << ": Failed to destroy sockets for UID " << CLOSE_UID << ": " <<
                         strerror(-ret);
                 break;
-            case UIDRANGE: {
+            }
+            case UIDRANGE:
+            case UIDRANGE_EXCLUDE_LOOPBACK: {
+                bool excludeLoopback = (mode == UIDRANGE_EXCLUDE_LOOPBACK);
                 const char *uidRangeStrings[] = { "8005-8012", "8042", "8043", "8090-8099" };
                 std::set<uid_t> skipUids { 8007, 8043, 8098, 8099 };
                 UidRanges uidRanges;
                 uidRanges.parseFrom(ARRAY_SIZE(uidRangeStrings), (char **) uidRangeStrings);
-                ret = mSd.destroySockets(uidRanges, skipUids);
+                ret = mSd.destroySockets(uidRanges, skipUids, excludeLoopback);
             }
         }
         return ret;
@@ -262,6 +370,9 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
                 }
                 return false;
             }
+            case UID_EXCLUDE_LOOPBACK:
+            case UIDRANGE_EXCLUDE_LOOPBACK:
+                return false;
         }
     }
 
@@ -341,7 +452,9 @@ TEST_P(SockDiagMicroBenchmarkTest, TestMicroBenchmark) {
     fprintf(stderr, "   Verifying: %6.1f ms (%d sockets destroyed)\n",
             std::chrono::duration_cast<ms>(std::chrono::steady_clock::now() - start).count(),
             socketsClosed);
-    EXPECT_GT(socketsClosed, 0);  // Just in case there's a bug in the test.
+    if (strstr(testTypeName(mode), "_EXCLUDE_LOOPBACK") == nullptr) {
+        EXPECT_GT(socketsClosed, 0);  // Just in case there's a bug in the test.
+    }
 
     start = std::chrono::steady_clock::now();
     for (int i = 0; i < numSockets; i++) {
@@ -358,4 +471,5 @@ TEST_P(SockDiagMicroBenchmarkTest, TestMicroBenchmark) {
 constexpr int SockDiagMicroBenchmarkTest::CLOSE_UID;
 
 INSTANTIATE_TEST_CASE_P(Address, SockDiagMicroBenchmarkTest,
-                        testing::Values(ADDRESS, UID, UIDRANGE));
+                        testing::Values(ADDRESS, UID, UIDRANGE,
+                                        UID_EXCLUDE_LOOPBACK, UIDRANGE_EXCLUDE_LOOPBACK));
diff --git a/server/VirtualNetwork.cpp b/server/VirtualNetwork.cpp
index 3d83703..6daa50d 100644
--- a/server/VirtualNetwork.cpp
+++ b/server/VirtualNetwork.cpp
@@ -54,7 +54,7 @@ int VirtualNetwork::maybeCloseSockets(bool add, const UidRanges& uidRanges,
         return -EBADFD;
     }
 
-    if (int ret = sd.destroySockets(uidRanges, protectableUsers)) {
+    if (int ret = sd.destroySockets(uidRanges, protectableUsers, true /* excludeLoopback */)) {
         ALOGE("Failed to close sockets while %s %s to network %d: %s",
               add ? "adding" : "removing", uidRanges.toString().c_str(), mNetId, strerror(-ret));
         return ret;

From a95e114a89aee4d7aef32263057beed2e2a31495 Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Tue, 26 Jul 2016 17:59:41 +0900
Subject: [PATCH 15/23] Allow networking on loopback in doze, standby, and
 powersave.

Restricting networking on loopback is needlessly restrictive
because it doesn't have substantial power impact.

Bug: 30186506

(cherry picked from commit 238e81894de39fe7c5ed74f297c36a4798008247)

Change-Id: I90130f3654a880a743ce6b66994306214d74b05c
---
 server/FirewallController.cpp     |  3 +++
 server/FirewallControllerTest.cpp |  5 +++++
 tests/binder_test.cpp             | 16 ++++++++--------
 3 files changed, 16 insertions(+), 8 deletions(-)

diff --git a/server/FirewallController.cpp b/server/FirewallController.cpp
index 839312d..826cf75 100644
--- a/server/FirewallController.cpp
+++ b/server/FirewallController.cpp
@@ -300,6 +300,9 @@ std::string FirewallController::makeUidRules(IptablesTarget target, const char *
     std::string commands;
     StringAppendF(&commands, "*filter\n:%s -\n", name);
 
+    // Always allow networking on loopback.
+    StringAppendF(&commands, "-A %s -i lo -o lo -j RETURN\n", name);
+
     // Allow TCP RSTs so we can cleanly close TCP connections of apps that no longer have network
     // access. Both incoming and outgoing RSTs are allowed.
     StringAppendF(&commands, "-A %s -p tcp --tcp-flags RST RST -j RETURN\n", name);
diff --git a/server/FirewallControllerTest.cpp b/server/FirewallControllerTest.cpp
index c1226b2..7d96c61 100644
--- a/server/FirewallControllerTest.cpp
+++ b/server/FirewallControllerTest.cpp
@@ -56,6 +56,7 @@ TEST_F(FirewallControllerTest, TestCreateWhitelistChain) {
     std::vector<std::string> expectedRestore4 = {
         "*filter",
         ":fw_whitelist -",
+        "-A fw_whitelist -i lo -o lo -j RETURN",
         "-A fw_whitelist -p tcp --tcp-flags RST RST -j RETURN",
         "-A fw_whitelist -m owner --uid-owner 0-9999 -j RETURN",
         "-A fw_whitelist -j DROP",
@@ -64,6 +65,7 @@ TEST_F(FirewallControllerTest, TestCreateWhitelistChain) {
     std::vector<std::string> expectedRestore6 = {
         "*filter",
         ":fw_whitelist -",
+        "-A fw_whitelist -i lo -o lo -j RETURN",
         "-A fw_whitelist -p tcp --tcp-flags RST RST -j RETURN",
         "-A fw_whitelist -p icmpv6 --icmpv6-type packet-too-big -j RETURN",
         "-A fw_whitelist -p icmpv6 --icmpv6-type router-solicitation -j RETURN",
@@ -93,6 +95,7 @@ TEST_F(FirewallControllerTest, TestCreateBlacklistChain) {
     std::vector<std::string> expectedRestore = {
         "*filter",
         ":fw_blacklist -",
+        "-A fw_blacklist -i lo -o lo -j RETURN",
         "-A fw_blacklist -p tcp --tcp-flags RST RST -j RETURN",
         "COMMIT\n\x04"
     };
@@ -138,6 +141,7 @@ TEST_F(FirewallControllerTest, TestReplaceWhitelistUidRule) {
     std::string expected =
             "*filter\n"
             ":FW_whitechain -\n"
+            "-A FW_whitechain -i lo -o lo -j RETURN\n"
             "-A FW_whitechain -p tcp --tcp-flags RST RST -j RETURN\n"
             "-A FW_whitechain -p icmpv6 --icmpv6-type packet-too-big -j RETURN\n"
             "-A FW_whitechain -p icmpv6 --icmpv6-type router-solicitation -j RETURN\n"
@@ -164,6 +168,7 @@ TEST_F(FirewallControllerTest, TestReplaceBlacklistUidRule) {
     std::string expected =
             "*filter\n"
             ":FW_blackchain -\n"
+            "-A FW_blackchain -i lo -o lo -j RETURN\n"
             "-A FW_blackchain -p tcp --tcp-flags RST RST -j RETURN\n"
             "-A FW_blackchain -m owner --uid-owner 10023 -j DROP\n"
             "-A FW_blackchain -m owner --uid-owner 10059 -j DROP\n"
diff --git a/tests/binder_test.cpp b/tests/binder_test.cpp
index 0fe6d5f..661680c 100644
--- a/tests/binder_test.cpp
+++ b/tests/binder_test.cpp
@@ -170,31 +170,31 @@ TEST_F(BinderTest, TestFirewallReplaceUidChain) {
         mNetd->firewallReplaceUidChain(String16(chainName.c_str()), true, uids, &ret);
     }
     EXPECT_EQ(true, ret);
-    EXPECT_EQ((int) uids.size() + 5, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
-    EXPECT_EQ((int) uids.size() + 11, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
+    EXPECT_EQ((int) uids.size() + 6, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
+    EXPECT_EQ((int) uids.size() + 12, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
     {
         TimedOperation op("Clearing whitelist chain");
         mNetd->firewallReplaceUidChain(String16(chainName.c_str()), false, noUids, &ret);
     }
     EXPECT_EQ(true, ret);
-    EXPECT_EQ(3, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
-    EXPECT_EQ(3, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
+    EXPECT_EQ(4, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
+    EXPECT_EQ(4, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
 
     {
         TimedOperation op(StringPrintf("Programming %d-UID blacklist chain", kNumUids));
         mNetd->firewallReplaceUidChain(String16(chainName.c_str()), false, uids, &ret);
     }
     EXPECT_EQ(true, ret);
-    EXPECT_EQ((int) uids.size() + 3, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
-    EXPECT_EQ((int) uids.size() + 3, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
+    EXPECT_EQ((int) uids.size() + 4, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
+    EXPECT_EQ((int) uids.size() + 4, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
 
     {
         TimedOperation op("Clearing blacklist chain");
         mNetd->firewallReplaceUidChain(String16(chainName.c_str()), false, noUids, &ret);
     }
     EXPECT_EQ(true, ret);
-    EXPECT_EQ(3, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
-    EXPECT_EQ(3, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
+    EXPECT_EQ(4, iptablesRuleLineLength(IPTABLES_PATH, chainName.c_str()));
+    EXPECT_EQ(4, iptablesRuleLineLength(IP6TABLES_PATH, chainName.c_str()));
 
     // Check that the call fails if iptables returns an error.
     std::string veryLongStringName = "netd_binder_test_UnacceptablyLongIptablesChainName";

From 9245fe7a16902a5a8cbbfc3dc36c74190fe453fe Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Mon, 1 Aug 2016 16:47:50 +0900
Subject: [PATCH 16/23] Enable IPv6 reverse path filtering.

Bug: 9580643
Bug: 30298058

(cherry picked from commit 8917e45f7f8d49b645fd6ed10942dfe20c71ac0e)

Change-Id: Iecd5fbe87e6d54ab129555ec4d6082ecad1d842f
---
 server/CommandListener.cpp   |  1 +
 server/NatController.cpp     | 30 ++++++++++++++++++++++++++++++
 server/NatController.h       |  1 +
 server/NatControllerTest.cpp |  6 ++++++
 4 files changed, 38 insertions(+)

diff --git a/server/CommandListener.cpp b/server/CommandListener.cpp
index e7bca55..e0f065e 100644
--- a/server/CommandListener.cpp
+++ b/server/CommandListener.cpp
@@ -135,6 +135,7 @@ static const char* FILTER_OUTPUT[] = {
 static const char* RAW_PREROUTING[] = {
         BandwidthController::LOCAL_RAW_PREROUTING,
         IdletimerController::LOCAL_RAW_PREROUTING,
+        NatController::LOCAL_RAW_PREROUTING,
         NULL,
 };
 
diff --git a/server/NatController.cpp b/server/NatController.cpp
index b978358..8b4ee11 100644
--- a/server/NatController.cpp
+++ b/server/NatController.cpp
@@ -38,6 +38,7 @@
 const char* NatController::LOCAL_FORWARD = "natctrl_FORWARD";
 const char* NatController::LOCAL_MANGLE_FORWARD = "natctrl_mangle_FORWARD";
 const char* NatController::LOCAL_NAT_POSTROUTING = "natctrl_nat_POSTROUTING";
+const char* NatController::LOCAL_RAW_PREROUTING = "natctrl_raw_PREROUTING";
 const char* NatController::LOCAL_TETHER_COUNTERS_CHAIN = "natctrl_tether_counters";
 
 auto NatController::execFunction = android_fork_execvp;
@@ -131,6 +132,7 @@ int NatController::setDefaults() {
         {{IP6TABLES_PATH, "-w", "-F", LOCAL_FORWARD,}, 1},
         {{IPTABLES_PATH, "-w", "-A", LOCAL_FORWARD, "-j", "DROP"}, 1},
         {{IPTABLES_PATH, "-w", "-t", "nat", "-F", LOCAL_NAT_POSTROUTING}, 1},
+        {{IP6TABLES_PATH, "-w", "-t", "raw", "-F", LOCAL_RAW_PREROUTING}, 1},
     };
     for (unsigned int cmdNum = 0; cmdNum < ARRAY_SIZE(defaultCommands); cmdNum++) {
         if (runCmd(ARRAY_SIZE(defaultCommands[cmdNum].cmd), defaultCommands[cmdNum].cmd) &&
@@ -343,6 +345,25 @@ int NatController::setForwardRules(bool add, const char *intIface, const char *e
             LOCAL_TETHER_COUNTERS_CHAIN
     };
 
+    const char *cmd4[] = {
+            IP6TABLES_PATH,
+            "-w",
+            "-t",
+            "raw",
+            add ? "-A" : "-D",
+            LOCAL_RAW_PREROUTING,
+            "-i",
+            intIface,
+            "-m",
+            "rpfilter",
+            "--invert",
+            "!",
+            "-s",
+            "fe80::/64",
+            "-j",
+            "DROP"
+    };
+
     if (runCmd(ARRAY_SIZE(cmd2), cmd2) && add) {
         // bail on error, but only if adding
         rc = -1;
@@ -355,6 +376,12 @@ int NatController::setForwardRules(bool add, const char *intIface, const char *e
         goto err_return;
     }
 
+    // STOPSHIP: Make this an error.
+    if (runCmd(ARRAY_SIZE(cmd4), cmd4) && add && false /* STOPSHIP */) {
+        rc = -1;
+        goto err_rpfilter;
+    }
+
     if (setTetherCountingRules(add, intIface, extIface) && add) {
         rc = -1;
         goto err_return;
@@ -362,6 +389,9 @@ int NatController::setForwardRules(bool add, const char *intIface, const char *e
 
     return 0;
 
+err_rpfilter:
+    cmd3[2] = "-D";
+    runCmd(ARRAY_SIZE(cmd3), cmd3);
 err_return:
     cmd2[2] = "-D";
     runCmd(ARRAY_SIZE(cmd2), cmd2);
diff --git a/server/NatController.h b/server/NatController.h
index 500385b..939f09d 100644
--- a/server/NatController.h
+++ b/server/NatController.h
@@ -33,6 +33,7 @@ class NatController {
     static const char* LOCAL_FORWARD;
     static const char* LOCAL_MANGLE_FORWARD;
     static const char* LOCAL_NAT_POSTROUTING;
+    static const char* LOCAL_RAW_PREROUTING;
     static const char* LOCAL_TETHER_COUNTERS_CHAIN;
 
     // List of strings of interface pairs.
diff --git a/server/NatControllerTest.cpp b/server/NatControllerTest.cpp
index e6c7b47..d1dcb11 100644
--- a/server/NatControllerTest.cpp
+++ b/server/NatControllerTest.cpp
@@ -51,12 +51,14 @@ class NatControllerTest : public IptablesBaseTest {
         { V4V6, "-F natctrl_FORWARD" },
         { V4,   "-A natctrl_FORWARD -j DROP" },
         { V4,   "-t nat -F natctrl_nat_POSTROUTING" },
+        { V6,   "-t raw -F natctrl_raw_PREROUTING" },
     };
 
     const ExpectedIptablesCommands SETUP_COMMANDS = {
         { V4V6, "-F natctrl_FORWARD" },
         { V4,   "-A natctrl_FORWARD -j DROP" },
         { V4,   "-t nat -F natctrl_nat_POSTROUTING" },
+        { V6,   "-t raw -F natctrl_raw_PREROUTING" },
         { V4V6, "-F natctrl_tether_counters" },
         { V4V6, "-X natctrl_tether_counters" },
         { V4V6, "-N natctrl_tether_counters" },
@@ -84,6 +86,8 @@ class NatControllerTest : public IptablesBaseTest {
                                  intIf, extIf) },
             { V4,   StringPrintf("-A natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
                                  intIf, extIf) },
+            { V6,   StringPrintf("-t raw -A natctrl_raw_PREROUTING -i %s -m rpfilter --invert"
+                                 " ! -s fe80::/64 -j DROP", intIf) },
             { V4V6, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN",
                                  intIf, extIf) },
             { V4V6, StringPrintf("-A natctrl_tether_counters -i %s -o %s -j RETURN",
@@ -99,6 +103,8 @@ class NatControllerTest : public IptablesBaseTest {
                                intIf, extIf) },
             { V4, StringPrintf("-D natctrl_FORWARD -i %s -o %s -g natctrl_tether_counters",
                                intIf, extIf) },
+            { V6, StringPrintf("-t raw -D natctrl_raw_PREROUTING -i %s -m rpfilter --invert"
+                               " ! -s fe80::/64 -j DROP", intIf) },
         };
     }
 };

From 219672ac2a052d995219cca3700e09157c3dc45a Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Mon, 1 Aug 2016 18:14:31 +0900
Subject: [PATCH 17/23] Don't start tethering if IPv6 RPF is not supported.

Bug: 9580643
Bug: 30298058

(cherry picked from commit bd96d9582e719c5cbc68fd59aa8e6f703b510eb3)

Change-Id: I7676ea379322567d9a103bb26510866965a5ea99
---
 server/NatController.cpp | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/server/NatController.cpp b/server/NatController.cpp
index 8b4ee11..cda8f5f 100644
--- a/server/NatController.cpp
+++ b/server/NatController.cpp
@@ -376,8 +376,7 @@ int NatController::setForwardRules(bool add, const char *intIface, const char *e
         goto err_return;
     }
 
-    // STOPSHIP: Make this an error.
-    if (runCmd(ARRAY_SIZE(cmd4), cmd4) && add && false /* STOPSHIP */) {
+    if (runCmd(ARRAY_SIZE(cmd4), cmd4) && add) {
         rc = -1;
         goto err_rpfilter;
     }

From 53c2088c4091e511c713ee759ce905e40e6d8975 Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Tue, 2 Aug 2016 15:22:53 +0900
Subject: [PATCH 18/23] Support adding/removing IPv4 and IPv6 addresses on
 interfaces

Bug: 30298058

(cherry picked from commit c296f098b63a986265ded8adf13118ba512a0fa7)

Change-Id: I4e40f4c0fe82696dc580d30e50e8c5b9fe17be88
---
 server/InterfaceController.cpp       | 12 ++++++++++++
 server/InterfaceController.h         |  2 ++
 server/NetdNativeService.cpp         | 26 ++++++++++++++++++++++++++
 server/NetdNativeService.h           |  5 +++++
 server/binder/android/net/INetd.aidl | 15 +++++++++++++++
 5 files changed, 60 insertions(+)

diff --git a/server/InterfaceController.cpp b/server/InterfaceController.cpp
index cbc3611..4129c0f 100644
--- a/server/InterfaceController.cpp
+++ b/server/InterfaceController.cpp
@@ -23,6 +23,7 @@
 #include <android-base/stringprintf.h>
 #include <cutils/log.h>
 #include <logwrap/logwrap.h>
+#include <netutils/ifc.h>
 
 #include "InterfaceController.h"
 #include "RouteController.h"
@@ -192,6 +193,17 @@ int InterfaceController::setMtu(const char *interface, const char *mtu)
     return writeValueToPath(sys_net_path, interface, "mtu", mtu);
 }
 
+
+int InterfaceController::addAddress(const char *interface,
+        const char *addrString, int prefixLength) {
+    return ifc_add_address(interface, addrString, prefixLength);
+}
+
+int InterfaceController::delAddress(const char *interface,
+        const char *addrString, int prefixLength) {
+    return ifc_del_address(interface, addrString, prefixLength);
+}
+
 void InterfaceController::setBaseReachableTimeMs(unsigned int millis) {
     std::string value(StringPrintf("%u", millis));
     setOnAllInterfaces(ipv4_neigh_conf_dir, "base_reachable_time_ms", value.c_str());
diff --git a/server/InterfaceController.h b/server/InterfaceController.h
index 4c8057e..356cc5a 100644
--- a/server/InterfaceController.h
+++ b/server/InterfaceController.h
@@ -27,6 +27,8 @@ class InterfaceController {
     static int setIPv6PrivacyExtensions(const char *interface, const int on);
     static int setIPv6NdOffload(char* interface, const int on);
     static int setMtu(const char *interface, const char *mtu);
+    static int addAddress(const char *interface, const char *addrString, int prefixLength);
+    static int delAddress(const char *interface, const char *addrString, int prefixLength);
 
 private:
     static void setAcceptRA(const char* value);
diff --git a/server/NetdNativeService.cpp b/server/NetdNativeService.cpp
index 5e5b8fd..8dc4d93 100644
--- a/server/NetdNativeService.cpp
+++ b/server/NetdNativeService.cpp
@@ -209,5 +209,31 @@ binder::Status NetdNativeService::tetherApplyDnsInterfaces(bool *ret) {
     return binder::Status::ok();
 }
 
+binder::Status NetdNativeService::interfaceAddAddress(const std::string &ifName,
+        const std::string &addrString, int prefixLength) {
+    ENFORCE_PERMISSION(CONNECTIVITY_INTERNAL);
+
+    const int err = InterfaceController::addAddress(
+            ifName.c_str(), addrString.c_str(), prefixLength);
+    if (err != 0) {
+        return binder::Status::fromServiceSpecificError(-err,
+                String8::format("InterfaceController error: %s", strerror(-err)));
+    }
+    return binder::Status::ok();
+}
+
+binder::Status NetdNativeService::interfaceDelAddress(const std::string &ifName,
+        const std::string &addrString, int prefixLength) {
+    ENFORCE_PERMISSION(CONNECTIVITY_INTERNAL);
+
+    const int err = InterfaceController::delAddress(
+            ifName.c_str(), addrString.c_str(), prefixLength);
+    if (err != 0) {
+        return binder::Status::fromServiceSpecificError(-err,
+                String8::format("InterfaceController error: %s", strerror(-err)));
+    }
+    return binder::Status::ok();
+}
+
 }  // namespace net
 }  // namespace android
diff --git a/server/NetdNativeService.h b/server/NetdNativeService.h
index c5d9114..c39e2a8 100644
--- a/server/NetdNativeService.h
+++ b/server/NetdNativeService.h
@@ -50,6 +50,11 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
 
     // Tethering-related commands.
     binder::Status tetherApplyDnsInterfaces(bool *ret) override;
+
+    binder::Status interfaceAddAddress(const std::string &ifName,
+            const std::string &addrString, int prefixLength) override;
+    binder::Status interfaceDelAddress(const std::string &ifName,
+            const std::string &addrString, int prefixLength) override;
 };
 
 }  // namespace net
diff --git a/server/binder/android/net/INetd.aidl b/server/binder/android/net/INetd.aidl
index 1b901b8..e092b76 100644
--- a/server/binder/android/net/INetd.aidl
+++ b/server/binder/android/net/INetd.aidl
@@ -155,4 +155,19 @@ interface INetd {
      * TODO: Return something richer than just a boolean.
      */
     boolean tetherApplyDnsInterfaces();
+
+    /**
+     * Add/Remove and IP address from an interface.
+     *
+     * @param ifName the interface name
+     * @param addrString the IP address to add/remove as a string literal
+     * @param prefixLength the prefix length associated with this IP address
+     *
+     * @throws ServiceSpecificException in case of failure, with an error code corresponding to the
+     *         unix errno.
+     */
+    void interfaceAddAddress(in @utf8InCpp String ifName, in @utf8InCpp String addrString,
+            int prefixLength);
+    void interfaceDelAddress(in @utf8InCpp String ifName, in @utf8InCpp String addrString,
+            int prefixLength);
 }

From cc4f273830144d415cfba01d65314606c444577d Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Wed, 3 Aug 2016 11:24:27 +0900
Subject: [PATCH 19/23] Add tests for interface add/remove binder API

Bug: 30298058

(cherry picked from commit 46ae27cd20e70393843799efe8de9180295a4953)

Change-Id: I06cd226c75a8cc42eac5b5d1d27031af30c0662e
---
 server/NetdConstants.h |  24 ++++++++
 server/SockDiag.cpp    |   6 --
 tests/binder_test.cpp  | 163 ++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 186 insertions(+), 7 deletions(-)

diff --git a/server/NetdConstants.h b/server/NetdConstants.h
index e3f533a..605362c 100644
--- a/server/NetdConstants.h
+++ b/server/NetdConstants.h
@@ -19,6 +19,8 @@
 
 #include <string>
 #include <list>
+#include <ifaddrs.h>
+#include <netdb.h>
 #include <stdarg.h>
 
 #include <chrono>
@@ -73,6 +75,28 @@ class Stopwatch {
     std::chrono::time_point<std::chrono::steady_clock> mStart;
 };
 
+
+struct AddrinfoDeleter {
+    void operator()(struct addrinfo* p) const {
+        if (p != nullptr) {
+            freeaddrinfo(p);
+        }
+    }
+};
+
+typedef std::unique_ptr<struct addrinfo, struct AddrinfoDeleter> ScopedAddrinfo;
+
+
+struct IfaddrsDeleter {
+    void operator()(struct ifaddrs *p) const {
+        if (p != nullptr) {
+            freeifaddrs(p);
+        }
+    }
+};
+
+typedef std::unique_ptr<struct ifaddrs, struct IfaddrsDeleter> ScopedIfaddrs;
+
 namespace android {
 namespace net {
 
diff --git a/server/SockDiag.cpp b/server/SockDiag.cpp
index 6b93a97..55d8dea 100644
--- a/server/SockDiag.cpp
+++ b/server/SockDiag.cpp
@@ -42,12 +42,6 @@
 
 namespace {
 
-struct AddrinfoDeleter {
-  void operator()(addrinfo *a) { if (a) freeaddrinfo(a); }
-};
-
-typedef std::unique_ptr<addrinfo, AddrinfoDeleter> ScopedAddrinfo;
-
 int checkError(int fd) {
     struct {
         nlmsghdr h;
diff --git a/tests/binder_test.cpp b/tests/binder_test.cpp
index 661680c..9909aef 100644
--- a/tests/binder_test.cpp
+++ b/tests/binder_test.cpp
@@ -25,6 +25,7 @@
 #include <vector>
 
 #include <fcntl.h>
+#include <ifaddrs.h>
 #include <netdb.h>
 #include <sys/socket.h>
 #include <sys/types.h>
@@ -32,6 +33,7 @@
 #include <linux/if.h>
 #include <linux/if_tun.h>
 
+#include <android-base/macros.h>
 #include <android-base/stringprintf.h>
 #include <android-base/strings.h>
 #include <cutils/multiuser.h>
@@ -73,6 +75,7 @@ class BinderTest : public ::testing::Test {
     // Static because setting up the tun interface takes about 40ms.
     static void SetUpTestCase() {
         sTunFd = createTunInterface();
+        ASSERT_LE(sTunIfName.size(), static_cast<size_t>(IFNAMSIZ));
         ASSERT_NE(-1, sTunFd);
     }
 
@@ -87,11 +90,13 @@ class BinderTest : public ::testing::Test {
 protected:
     sp<INetd> mNetd;
     static int sTunFd;
+    static std::string sTunIfName;
     static in6_addr sSrcAddr, sDstAddr;
     static char sSrcStr[], sDstStr[];
 };
 
 int BinderTest::sTunFd;
+std::string BinderTest::sTunIfName;
 in6_addr BinderTest::sSrcAddr;
 in6_addr BinderTest::sDstAddr;
 char BinderTest::sSrcStr[INET6_ADDRSTRLEN];
@@ -343,10 +348,11 @@ int BinderTest::createTunInterface() {
     }
 
     // Create a tun interface with a name based on our PID.
+    sTunIfName = StringPrintf("netdtest%u", getpid());
     struct ifreq ifr = {
         .ifr_ifru = { .ifru_flags = IFF_TUN },
     };
-    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "netdtest%u", getpid());
+    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", sTunIfName.c_str());
 
     int fd = open(TUN_DEV, O_RDWR | O_NONBLOCK | O_CLOEXEC);
     EXPECT_NE(-1, fd) << TUN_DEV << ": " << strerror(errno);
@@ -456,3 +462,158 @@ TEST_F(BinderTest, TestSocketDestroy) {
     close(serverSocket);
     close(acceptedSocket);
 }
+
+namespace {
+
+int netmaskToPrefixLength(const uint8_t *buf, size_t buflen) {
+    if (buf == nullptr) return -1;
+
+    int prefixLength = 0;
+    bool endOfContiguousBits = false;
+    for (unsigned int i = 0; i < buflen; i++) {
+        const uint8_t value = buf[i];
+
+        // Bad bit sequence: check for a contiguous set of bits from the high
+        // end by verifying that the inverted value + 1 is a power of 2
+        // (power of 2 iff. (v & (v - 1)) == 0).
+        const uint8_t inverse = ~value + 1;
+        if ((inverse & (inverse - 1)) != 0) return -1;
+
+        prefixLength += (value == 0) ? 0 : CHAR_BIT - ffs(value) + 1;
+
+        // Bogus netmask.
+        if (endOfContiguousBits && value != 0) return -1;
+
+        if (value != 0xff) endOfContiguousBits = true;
+    }
+
+    return prefixLength;
+}
+
+template<typename T>
+int netmaskToPrefixLength(const T *p) {
+    return netmaskToPrefixLength(reinterpret_cast<const uint8_t*>(p), sizeof(T));
+}
+
+
+static bool interfaceHasAddress(
+        const std::string &ifname, const char *addrString, int prefixLength) {
+    struct addrinfo *addrinfoList = nullptr;
+    ScopedAddrinfo addrinfoCleanup(addrinfoList);
+
+    const struct addrinfo hints = {
+        .ai_flags    = AI_NUMERICHOST,
+        .ai_family   = AF_UNSPEC,
+        .ai_socktype = SOCK_DGRAM,
+    };
+    if (getaddrinfo(addrString, nullptr, &hints, &addrinfoList) != 0 ||
+        addrinfoList == nullptr || addrinfoList->ai_addr == nullptr) {
+        return false;
+    }
+
+    struct ifaddrs *ifaddrsList = nullptr;
+    ScopedIfaddrs ifaddrsCleanup(ifaddrsList);
+
+    if (getifaddrs(&ifaddrsList) != 0) {
+        return false;
+    }
+
+    for (struct ifaddrs *addr = ifaddrsList; addr != nullptr; addr = addr->ifa_next) {
+        if (std::string(addr->ifa_name) != ifname ||
+            addr->ifa_addr == nullptr ||
+            addr->ifa_addr->sa_family != addrinfoList->ai_addr->sa_family) {
+            continue;
+        }
+
+        switch (addr->ifa_addr->sa_family) {
+        case AF_INET: {
+            auto *addr4 = reinterpret_cast<const struct sockaddr_in*>(addr->ifa_addr);
+            auto *want = reinterpret_cast<const struct sockaddr_in*>(addrinfoList->ai_addr);
+            if (memcmp(&addr4->sin_addr, &want->sin_addr, sizeof(want->sin_addr)) != 0) {
+                continue;
+            }
+
+            if (prefixLength < 0) return true;  // not checking prefix lengths
+
+            if (addr->ifa_netmask == nullptr) return false;
+            auto *nm = reinterpret_cast<const struct sockaddr_in*>(addr->ifa_netmask);
+            EXPECT_EQ(prefixLength, netmaskToPrefixLength(&nm->sin_addr));
+            return (prefixLength == netmaskToPrefixLength(&nm->sin_addr));
+        }
+        case AF_INET6: {
+            auto *addr6 = reinterpret_cast<const struct sockaddr_in6*>(addr->ifa_addr);
+            auto *want = reinterpret_cast<const struct sockaddr_in6*>(addrinfoList->ai_addr);
+            if (memcmp(&addr6->sin6_addr, &want->sin6_addr, sizeof(want->sin6_addr)) != 0) {
+                continue;
+            }
+
+            if (prefixLength < 0) return true;  // not checking prefix lengths
+
+            if (addr->ifa_netmask == nullptr) return false;
+            auto *nm = reinterpret_cast<const struct sockaddr_in6*>(addr->ifa_netmask);
+            EXPECT_EQ(prefixLength, netmaskToPrefixLength(&nm->sin6_addr));
+            return (prefixLength == netmaskToPrefixLength(&nm->sin6_addr));
+        }
+        default:
+            // Cannot happen because we have already screened for matching
+            // address families at the top of each iteration.
+            continue;
+        }
+    }
+
+    return false;
+}
+
+}  // namespace
+
+TEST_F(BinderTest, TestInterfaceAddRemoveAddress) {
+    static const struct TestData {
+        const char *addrString;
+        const int   prefixLength;
+        const bool  expectSuccess;
+    } kTestData[] = {
+        { "192.0.2.1", 24, true },
+        { "192.0.2.2", 25, true },
+        { "192.0.2.3", 32, true },
+        { "192.0.2.4", 33, false },
+        { "192.not.an.ip", 24, false },
+        { "2001:db8::1", 64, true },
+        { "2001:db8::2", 65, true },
+        { "2001:db8::3", 128, true },
+        { "2001:db8::4", 129, false },
+        { "foo:bar::bad", 64, false },
+    };
+
+    for (unsigned int i = 0; i < arraysize(kTestData); i++) {
+        const auto &td = kTestData[i];
+
+        // [1.a] Add the address.
+        binder::Status status = mNetd->interfaceAddAddress(
+                sTunIfName, td.addrString, td.prefixLength);
+        if (td.expectSuccess) {
+            EXPECT_TRUE(status.isOk()) << status.exceptionMessage();
+        } else {
+            ASSERT_EQ(binder::Status::EX_SERVICE_SPECIFIC, status.exceptionCode());
+            ASSERT_NE(0, status.serviceSpecificErrorCode());
+        }
+
+        // [1.b] Verify the addition meets the expectation.
+        if (td.expectSuccess) {
+            EXPECT_TRUE(interfaceHasAddress(sTunIfName, td.addrString, td.prefixLength));
+        } else {
+            EXPECT_FALSE(interfaceHasAddress(sTunIfName, td.addrString, -1));
+        }
+
+        // [2.a] Try to remove the address.  If it was not previously added, removing it fails.
+        status = mNetd->interfaceDelAddress(sTunIfName, td.addrString, td.prefixLength);
+        if (td.expectSuccess) {
+            EXPECT_TRUE(status.isOk()) << status.exceptionMessage();
+        } else {
+            ASSERT_EQ(binder::Status::EX_SERVICE_SPECIFIC, status.exceptionCode());
+            ASSERT_NE(0, status.serviceSpecificErrorCode());
+        }
+
+        // [2.b] No matter what, the address should not be present.
+        EXPECT_FALSE(interfaceHasAddress(sTunIfName, td.addrString, -1));
+    }
+}

From 6cddf5193149ae8a072e8e0c9bf4a97cab3feb62 Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Tue, 9 Aug 2016 15:28:42 +0900
Subject: [PATCH 20/23] Disable DAD for downstream interfaces when tethering

Bug: 30298058

(cherry picked from commit 59d8c48cee74679d2305c535ab61d4a6f8258c64)

Change-Id: I60929eecf4a890b9c23bf1ba1ba5273db3ccb493
---
 server/InterfaceController.cpp | 8 ++++++++
 server/InterfaceController.h   | 1 +
 server/TetherController.cpp    | 4 ++++
 3 files changed, 13 insertions(+)

diff --git a/server/InterfaceController.cpp b/server/InterfaceController.cpp
index 4129c0f..eac4fbf 100644
--- a/server/InterfaceController.cpp
+++ b/server/InterfaceController.cpp
@@ -136,6 +136,14 @@ int InterfaceController::setAcceptIPv6Dad(const char *interface, const int on) {
     return writeValueToPath(ipv6_proc_path, interface, "accept_dad", accept_dad);
 }
 
+int InterfaceController::setIPv6DadTransmits(const char *interface, const char *value) {
+    if (!isIfaceName(interface)) {
+        errno = ENOENT;
+        return -1;
+    }
+    return writeValueToPath(ipv6_proc_path, interface, "dad_transmits", value);
+}
+
 int InterfaceController::setIPv6PrivacyExtensions(const char *interface, const int on) {
     if (!isIfaceName(interface)) {
         errno = ENOENT;
diff --git a/server/InterfaceController.h b/server/InterfaceController.h
index 356cc5a..98c8b8f 100644
--- a/server/InterfaceController.h
+++ b/server/InterfaceController.h
@@ -24,6 +24,7 @@ class InterfaceController {
     static int setEnableIPv6(const char *interface, const int on);
     static int setAcceptIPv6Ra(const char *interface, const int on);
     static int setAcceptIPv6Dad(const char *interface, const int on);
+    static int setIPv6DadTransmits(const char *interface, const char *value);
     static int setIPv6PrivacyExtensions(const char *interface, const int on);
     static int setIPv6NdOffload(char* interface, const int on);
     static int setMtu(const char *interface, const char *mtu);
diff --git a/server/TetherController.cpp b/server/TetherController.cpp
index 971104f..6617c6a 100644
--- a/server/TetherController.cpp
+++ b/server/TetherController.cpp
@@ -65,11 +65,15 @@ bool writeToFile(const char* filename, const char* value) {
 bool configureForIPv6Router(const char *interface) {
     return (InterfaceController::setEnableIPv6(interface, 0) == 0)
             && (InterfaceController::setAcceptIPv6Ra(interface, 0) == 0)
+            && (InterfaceController::setAcceptIPv6Dad(interface, 0) == 0)
+            && (InterfaceController::setIPv6DadTransmits(interface, "0") == 0)
             && (InterfaceController::setEnableIPv6(interface, 1) == 0);
 }
 
 void configureForIPv6Client(const char *interface) {
     InterfaceController::setAcceptIPv6Ra(interface, 1);
+    InterfaceController::setAcceptIPv6Dad(interface, 1);
+    InterfaceController::setIPv6DadTransmits(interface, "1");
     InterfaceController::setEnableIPv6(interface, 0);
 }
 

From 55b06f85b13553b7b0b5a76f650f452d5a9473c5 Mon Sep 17 00:00:00 2001
From: Erik Kline <ek@google.com>
Date: Mon, 4 Jul 2016 09:57:18 +0900
Subject: [PATCH 21/23] Add general /proc/sys/net/ipv[46]/{conf,neigh}/
 interface

Bug: 21859053
Bug: 28135208

(cherry picked from commit b218a87e0777d3d2c93231e03ef7315d783e3279)

Change-Id: Ie32c86511b97358d208a4c84a1c69a75c703bf3b
---
 server/InterfaceController.cpp       | 58 ++++++++++++++++++++++++++++++++----
 server/InterfaceController.h         | 11 +++++++
 server/NetdNativeService.cpp         | 40 +++++++++++++++++++++++++
 server/NetdNativeService.h           |  4 +++
 server/binder/android/net/INetd.aidl | 18 +++++++++++
 tests/binder_test.cpp                | 37 +++++++++++++++++++++++
 6 files changed, 162 insertions(+), 6 deletions(-)

diff --git a/server/InterfaceController.cpp b/server/InterfaceController.cpp
index eac4fbf..1d0a8e0 100644
--- a/server/InterfaceController.cpp
+++ b/server/InterfaceController.cpp
@@ -17,6 +17,7 @@
 #include <dirent.h>
 #include <errno.h>
 #include <malloc.h>
+#include <sys/socket.h>
 
 #define LOG_TAG "InterfaceController"
 #include <android-base/file.h>
@@ -29,6 +30,7 @@
 #include "RouteController.h"
 
 using android::base::StringPrintf;
+using android::base::ReadFileToString;
 using android::base::WriteStringToFile;
 
 namespace {
@@ -39,15 +41,25 @@ const char ipv4_neigh_conf_dir[] = "/proc/sys/net/ipv4/neigh";
 
 const char ipv6_neigh_conf_dir[] = "/proc/sys/net/ipv6/neigh";
 
+const char proc_net_path[] = "/proc/sys/net";
 const char sys_net_path[] = "/sys/class/net";
 
 const char wl_util_path[] = "/vendor/xbin/wlutil";
 
-bool isInterfaceName(const char *name) {
-    return strcmp(name, ".") &&
-            strcmp(name, "..") &&
-            strcmp(name, "default") &&
-            strcmp(name, "all");
+inline bool isNormalPathComponent(const char *component) {
+    return (strcmp(component, ".") != 0) &&
+           (strcmp(component, "..") != 0) &&
+           (strchr(component, '/') == nullptr);
+}
+
+inline bool isAddressFamilyPathComponent(const char *component) {
+    return strcmp(component, "ipv4") == 0 || strcmp(component, "ipv6") == 0;
+}
+
+inline bool isInterfaceName(const char *name) {
+    return isNormalPathComponent(name) &&
+           (strcmp(name, "default") != 0) &&
+           (strcmp(name, "all") != 0);
 }
 
 int writeValueToPath(
@@ -81,6 +93,21 @@ void setIPv6UseOutgoingInterfaceAddrsOnly(const char *value) {
     setOnAllInterfaces(ipv6_proc_path, "use_oif_addrs_only", value);
 }
 
+std::string getParameterPathname(
+        const char *family, const char *which, const char *interface, const char *parameter) {
+    if (!isAddressFamilyPathComponent(family)) {
+        errno = EAFNOSUPPORT;
+        return "";
+    } else if (!isNormalPathComponent(which) ||
+               !isInterfaceName(interface) ||
+               !isNormalPathComponent(parameter)) {
+        errno = EINVAL;
+        return "";
+    }
+
+    return StringPrintf("%s/%s/%s/%s/%s", proc_net_path, family, which, interface, parameter);
+}
+
 }  // namespace
 
 void InterfaceController::initializeAll() {
@@ -201,7 +228,6 @@ int InterfaceController::setMtu(const char *interface, const char *mtu)
     return writeValueToPath(sys_net_path, interface, "mtu", mtu);
 }
 
-
 int InterfaceController::addAddress(const char *interface,
         const char *addrString, int prefixLength) {
     return ifc_add_address(interface, addrString, prefixLength);
@@ -212,6 +238,26 @@ int InterfaceController::delAddress(const char *interface,
     return ifc_del_address(interface, addrString, prefixLength);
 }
 
+int InterfaceController::getParameter(
+        const char *family, const char *which, const char *interface, const char *parameter,
+        std::string *value) {
+    const std::string path(getParameterPathname(family, which, interface, parameter));
+    if (path.empty()) {
+        return -errno;
+    }
+    return ReadFileToString(path, value) ? 0 : -errno;
+}
+
+int InterfaceController::setParameter(
+        const char *family, const char *which, const char *interface, const char *parameter,
+        const char *value) {
+    const std::string path(getParameterPathname(family, which, interface, parameter));
+    if (path.empty()) {
+        return -errno;
+    }
+    return WriteStringToFile(value, path) ? 0 : -errno;
+}
+
 void InterfaceController::setBaseReachableTimeMs(unsigned int millis) {
     std::string value(StringPrintf("%u", millis));
     setOnAllInterfaces(ipv4_neigh_conf_dir, "base_reachable_time_ms", value.c_str());
diff --git a/server/InterfaceController.h b/server/InterfaceController.h
index 98c8b8f..80ebe5c 100644
--- a/server/InterfaceController.h
+++ b/server/InterfaceController.h
@@ -17,6 +17,8 @@
 #ifndef _INTERFACE_CONTROLLER_H
 #define _INTERFACE_CONTROLLER_H
 
+#include <string>
+
 class InterfaceController {
 public:
     static void initializeAll();
@@ -31,6 +33,15 @@ class InterfaceController {
     static int addAddress(const char *interface, const char *addrString, int prefixLength);
     static int delAddress(const char *interface, const char *addrString, int prefixLength);
 
+    // Read and write values in files of the form:
+    //     /proc/sys/net/<family>/<which>/<interface>/<parameter>
+    static int getParameter(
+            const char *family, const char *which, const char *interface, const char *parameter,
+            std::string *value);
+    static int setParameter(
+            const char *family, const char *which, const char *interface, const char *parameter,
+            const char *value);
+
 private:
     static void setAcceptRA(const char* value);
     static void setAcceptRARouteTable(int tableOrOffset);
diff --git a/server/NetdNativeService.cpp b/server/NetdNativeService.cpp
index 8dc4d93..f8f300a 100644
--- a/server/NetdNativeService.cpp
+++ b/server/NetdNativeService.cpp
@@ -29,6 +29,7 @@
 
 #include "Controllers.h"
 #include "DumpWriter.h"
+#include "InterfaceController.h"
 #include "NetdConstants.h"
 #include "NetdNativeService.h"
 #include "RouteController.h"
@@ -235,5 +236,44 @@ binder::Status NetdNativeService::interfaceDelAddress(const std::string &ifName,
     return binder::Status::ok();
 }
 
+binder::Status NetdNativeService::setProcSysNet(
+        int32_t family, int32_t which, const std::string &ifname, const std::string &parameter,
+        const std::string &value) {
+    ENFORCE_PERMISSION(CONNECTIVITY_INTERNAL);
+
+    const char *familyStr;
+    switch (family) {
+        case INetd::IPV4:
+            familyStr = "ipv4";
+            break;
+        case INetd::IPV6:
+            familyStr = "ipv6";
+            break;
+        default:
+            return binder::Status::fromServiceSpecificError(EAFNOSUPPORT, String8("Bad family"));
+    }
+
+    const char *whichStr;
+    switch (which) {
+        case INetd::CONF:
+            whichStr = "conf";
+            break;
+        case INetd::NEIGH:
+            whichStr = "neigh";
+            break;
+        default:
+            return binder::Status::fromServiceSpecificError(EINVAL, String8("Bad category"));
+    }
+
+    const int err = InterfaceController::setParameter(
+            familyStr, whichStr, ifname.c_str(), parameter.c_str(),
+            value.c_str());
+    if (err != 0) {
+        return binder::Status::fromServiceSpecificError(-err,
+                String8::format("ResolverController error: %s", strerror(-err)));
+    }
+    return binder::Status::ok();
+}
+
 }  // namespace net
 }  // namespace android
diff --git a/server/NetdNativeService.h b/server/NetdNativeService.h
index c39e2a8..7e1d75e 100644
--- a/server/NetdNativeService.h
+++ b/server/NetdNativeService.h
@@ -55,6 +55,10 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
             const std::string &addrString, int prefixLength) override;
     binder::Status interfaceDelAddress(const std::string &ifName,
             const std::string &addrString, int prefixLength) override;
+
+    binder::Status setProcSysNet(
+            int32_t family, int32_t which, const std::string &ifname, const std::string &parameter,
+            const std::string &value) override;
 };
 
 }  // namespace net
diff --git a/server/binder/android/net/INetd.aidl b/server/binder/android/net/INetd.aidl
index e092b76..9df392a 100644
--- a/server/binder/android/net/INetd.aidl
+++ b/server/binder/android/net/INetd.aidl
@@ -170,4 +170,22 @@ interface INetd {
             int prefixLength);
     void interfaceDelAddress(in @utf8InCpp String ifName, in @utf8InCpp String addrString,
             int prefixLength);
+
+    /*
+     * Set and get /proc/sys/net interface configuration parameters.
+     *
+     * @param family One of IPV4/IPV6 integers, indicating the desired address family directory.
+     * @param which One of CONF/NEIGH integers, indicating the desired parameter category directory.
+     * @param ifname The interface name portion of the path; may also be "all" or "default".
+     * @param parameter The parameter name portion of the path.
+     * @param value The value string to be written into the assembled path.
+     */
+
+    const int IPV4  = 4;
+    const int IPV6  = 6;
+    const int CONF  = 1;
+    const int NEIGH = 2;
+    void setProcSysNet(int family, int which, in @utf8InCpp String ifname,
+            in @utf8InCpp String parameter, in @utf8InCpp String value);
+    // TODO: add corresponding getProcSysNet().
 }
diff --git a/tests/binder_test.cpp b/tests/binder_test.cpp
index 9909aef..fd94d2e 100644
--- a/tests/binder_test.cpp
+++ b/tests/binder_test.cpp
@@ -617,3 +617,40 @@ TEST_F(BinderTest, TestInterfaceAddRemoveAddress) {
         EXPECT_FALSE(interfaceHasAddress(sTunIfName, td.addrString, -1));
     }
 }
+
+TEST_F(BinderTest, TestSetProcSysNet) {
+    static const struct TestData {
+        const int family;
+        const int which;
+        const char *ifname;
+        const char *parameter;
+        const char *value;
+        const int expectedReturnCode;
+    } kTestData[] = {
+        { INetd::IPV4, INetd::CONF, sTunIfName.c_str(), "arp_ignore", "1", 0 },
+        { -1, INetd::CONF, sTunIfName.c_str(), "arp_ignore", "1", EAFNOSUPPORT },
+        { INetd::IPV4, -1, sTunIfName.c_str(), "arp_ignore", "1", EINVAL },
+        { INetd::IPV4, INetd::CONF, "..", "conf/lo/arp_ignore", "1", EINVAL },
+        { INetd::IPV4, INetd::CONF, ".", "lo/arp_ignore", "1", EINVAL },
+        { INetd::IPV4, INetd::CONF, sTunIfName.c_str(), "../all/arp_ignore", "1", EINVAL },
+        { INetd::IPV6, INetd::NEIGH, sTunIfName.c_str(), "ucast_solicit", "7", 0 },
+    };
+
+    for (unsigned int i = 0; i < arraysize(kTestData); i++) {
+        const auto &td = kTestData[i];
+
+        const binder::Status status = mNetd->setProcSysNet(
+                    td.family, td.which, td.ifname, td.parameter,
+                    td.value);
+
+        if (td.expectedReturnCode == 0) {
+            SCOPED_TRACE(String8::format("test case %d should have passed", i));
+            EXPECT_EQ(0, status.exceptionCode());
+            EXPECT_EQ(0, status.serviceSpecificErrorCode());
+        } else {
+            SCOPED_TRACE(String8::format("test case %d should have failed", i));
+            EXPECT_EQ(binder::Status::EX_SERVICE_SPECIFIC, status.exceptionCode());
+            EXPECT_EQ(td.expectedReturnCode, status.serviceSpecificErrorCode());
+        }
+    }
+}

From fbe76b984233d0d8a84f5eafeaa01da7151c64ad Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Wed, 14 Sep 2016 02:25:05 +0900
Subject: [PATCH 22/23] Close sockets when changing network permissions.

Bug: 23113288

(cherry picked from commit c6201c3754710e235f16118761b23760ff4136ad)

Change-Id: I1407644e06e960e453a31b298e46ef866f0eebd2
---
 server/NetworkController.cpp |   2 -
 server/PhysicalNetwork.cpp   |  28 +++++++++++
 server/PhysicalNetwork.h     |   1 +
 server/SockDiag.cpp          | 117 ++++++++++++++++++++++++++++++++++++++++---
 server/SockDiag.h            |   7 ++-
 server/SockDiagTest.cpp      |  67 +++++++++++++++++++++++--
 6 files changed, 208 insertions(+), 14 deletions(-)

diff --git a/server/NetworkController.cpp b/server/NetworkController.cpp
index 014d926..aaf8b29 100644
--- a/server/NetworkController.cpp
+++ b/server/NetworkController.cpp
@@ -453,8 +453,6 @@ int NetworkController::setPermissionForNetworks(Permission permission,
             return -EINVAL;
         }
 
-        // TODO: ioctl(SIOCKILLADDR, ...) to kill socets on the network that don't have permission.
-
         if (int ret = static_cast<PhysicalNetwork*>(network)->setPermission(permission)) {
             return ret;
         }
diff --git a/server/PhysicalNetwork.cpp b/server/PhysicalNetwork.cpp
index 495a93a..ee0e7c7 100644
--- a/server/PhysicalNetwork.cpp
+++ b/server/PhysicalNetwork.cpp
@@ -17,6 +17,7 @@
 #include "PhysicalNetwork.h"
 
 #include "RouteController.h"
+#include "SockDiag.h"
 
 #define LOG_TAG "Netd"
 #include "log/log.h"
@@ -65,10 +66,33 @@ Permission PhysicalNetwork::getPermission() const {
     return mPermission;
 }
 
+int PhysicalNetwork::destroySocketsLackingPermission(Permission permission) {
+    if (permission == PERMISSION_NONE) return 0;
+
+    SockDiag sd;
+    if (!sd.open()) {
+       ALOGE("Error closing sockets for netId %d permission change", mNetId);
+       return -EBADFD;
+    }
+    if (int ret = sd.destroySocketsLackingPermission(mNetId, permission,
+                                                     true /* excludeLoopback */)) {
+        ALOGE("Failed to close sockets changing netId %d to permission %d: %s",
+              mNetId, permission, strerror(-ret));
+        return ret;
+    }
+    return 0;
+}
+
 int PhysicalNetwork::setPermission(Permission permission) {
     if (permission == mPermission) {
         return 0;
     }
+    if (mInterfaces.empty()) {
+        mPermission = permission;
+        return 0;
+    }
+
+    destroySocketsLackingPermission(permission);
     for (const std::string& interface : mInterfaces) {
         if (int ret = RouteController::modifyPhysicalNetworkPermission(mNetId, interface.c_str(),
                                                                        mPermission, permission)) {
@@ -87,6 +111,10 @@ int PhysicalNetwork::setPermission(Permission permission) {
             }
         }
     }
+    // Destroy sockets again in case any were opened after we called destroySocketsLackingPermission
+    // above and before we changed the permissions. These sockets won't be able to send any RST
+    // packets because they are now no longer routed, but at least the apps will get errors.
+    destroySocketsLackingPermission(permission);
     mPermission = permission;
     return 0;
 }
diff --git a/server/PhysicalNetwork.h b/server/PhysicalNetwork.h
index 2ef10df..cba3c6e 100644
--- a/server/PhysicalNetwork.h
+++ b/server/PhysicalNetwork.h
@@ -46,6 +46,7 @@ class PhysicalNetwork : public Network {
     Type getType() const override;
     int addInterface(const std::string& interface) override WARN_UNUSED_RESULT;
     int removeInterface(const std::string& interface) override WARN_UNUSED_RESULT;
+    int destroySocketsLackingPermission(Permission permission);
 
     Delegate* const mDelegate;
     Permission mPermission;
diff --git a/server/SockDiag.cpp b/server/SockDiag.cpp
index 55d8dea..f6b8b10 100644
--- a/server/SockDiag.cpp
+++ b/server/SockDiag.cpp
@@ -31,7 +31,9 @@
 #include <android-base/strings.h>
 #include <cutils/log.h>
 
+#include "Fwmark.h"
 #include "NetdConstants.h"
+#include "Permission.h"
 #include "SockDiag.h"
 
 #include <chrono>
@@ -40,6 +42,8 @@
 #define SOCK_DESTROY 21
 #endif
 
+#define INET_DIAG_BC_MARK_COND 10
+
 namespace {
 
 int checkError(int fd) {
@@ -186,9 +190,9 @@ int SockDiag::sendDumpRequest(uint8_t proto, uint8_t family, const char *addrstr
     attrs.nla.nla_len = sizeof(attrs) + addrlen;
 
     iovec iov[] = {
-        { nullptr, 0 },
-        { &attrs, sizeof(attrs) },
-        { addr, addrlen },
+        { nullptr,           0 },
+        { &attrs,            sizeof(attrs) },
+        { addr,              addrlen },
     };
 
     uint32_t states = ~(1 << TCP_TIME_WAIT);
@@ -316,18 +320,19 @@ int SockDiag::destroySockets(const char *addrstr) {
     return mSocketsDestroyed;
 }
 
-int SockDiag::destroyLiveSockets(DumpCallback destroyFilter) {
+int SockDiag::destroyLiveSockets(DumpCallback destroyFilter, const char *what,
+                                 iovec *iov, int iovcnt) {
     int proto = IPPROTO_TCP;
 
     for (const int family : {AF_INET, AF_INET6}) {
         const char *familyName = (family == AF_INET) ? "IPv4" : "IPv6";
         uint32_t states = (1 << TCP_ESTABLISHED) | (1 << TCP_SYN_SENT) | (1 << TCP_SYN_RECV);
-        if (int ret = sendDumpRequest(proto, family, states)) {
-            ALOGE("Failed to dump %s sockets for UID: %s", familyName, strerror(-ret));
+        if (int ret = sendDumpRequest(proto, family, states, iov, iovcnt)) {
+            ALOGE("Failed to dump %s sockets for %s: %s", familyName, what, strerror(-ret));
             return ret;
         }
         if (int ret = readDiagMsg(proto, destroyFilter)) {
-            ALOGE("Failed to destroy %s sockets for UID: %s", familyName, strerror(-ret));
+            ALOGE("Failed to destroy %s sockets for %s: %s", familyName, what, strerror(-ret));
             return ret;
         }
     }
@@ -377,7 +382,11 @@ int SockDiag::destroySockets(const UidRanges& uidRanges, const std::set<uid_t>&
                !(excludeLoopback && isLoopbackSocket(msg));
     };
 
-    if (int ret = destroyLiveSockets(shouldDestroy)) {
+    iovec iov[] = {
+        { nullptr, 0 },
+    };
+
+    if (int ret = destroyLiveSockets(shouldDestroy, "UID", iov, ARRAY_SIZE(iov))) {
         return ret;
     }
 
@@ -395,3 +404,95 @@ int SockDiag::destroySockets(const UidRanges& uidRanges, const std::set<uid_t>&
 
     return 0;
 }
+
+// Destroys all "live" (CONNECTED, SYN_SENT, SYN_RECV) TCP sockets on the specified netId where:
+// 1. The opening app no longer has permission to use this network, or:
+// 2. The opening app does have permission, but did not explicitly select this network.
+//
+// We destroy sockets without the explicit bit because we want to avoid the situation where a
+// privileged app uses its privileges without knowing it is doing so. For example, a privileged app
+// might have opened a socket on this network just because it was the default network at the
+// time. If we don't kill these sockets, those apps could continue to use them without realizing
+// that they are now sending and receiving traffic on a network that is now restricted.
+int SockDiag::destroySocketsLackingPermission(unsigned netId, Permission permission,
+                                              bool excludeLoopback) {
+    struct markmatch {
+        inet_diag_bc_op op;
+        // TODO: switch to inet_diag_markcond
+        __u32 mark;
+        __u32 mask;
+    } __attribute__((packed));
+    constexpr uint8_t matchlen = sizeof(markmatch);
+
+    Fwmark netIdMark, netIdMask;
+    netIdMark.netId = netId;
+    netIdMask.netId = 0xffff;
+
+    Fwmark controlMark;
+    controlMark.explicitlySelected = true;
+    controlMark.permission = permission;
+
+    // A SOCK_DIAG bytecode program that accepts the sockets we intend to destroy.
+    struct bytecode {
+        markmatch netIdMatch;
+        markmatch controlMatch;
+        inet_diag_bc_op controlJump;
+    } __attribute__((packed)) bytecode;
+
+    // The length of the INET_DIAG_BC_JMP instruction.
+    constexpr uint8_t jmplen = sizeof(inet_diag_bc_op);
+    // Jump exactly this far past the end of the program to reject.
+    constexpr uint8_t rejectoffset = sizeof(inet_diag_bc_op);
+    // Total length of the program.
+    constexpr uint8_t bytecodelen = sizeof(bytecode);
+
+    bytecode = (struct bytecode) {
+        // If netId matches, continue, otherwise, reject (i.e., leave socket alone).
+        { { INET_DIAG_BC_MARK_COND, matchlen, bytecodelen + rejectoffset },
+          netIdMark.intValue, netIdMask.intValue },
+
+        // If explicit and permission bits match, go to the JMP below which rejects the socket
+        // (i.e., we leave it alone). Otherwise, jump to the end of the program, which accepts the
+        // socket (so we destroy it).
+        { { INET_DIAG_BC_MARK_COND, matchlen, matchlen + jmplen },
+          controlMark.intValue, controlMark.intValue },
+
+        // This JMP unconditionally rejects the packet by jumping to the reject target. It is
+        // necessary to keep the kernel bytecode verifier happy. If we don't have a JMP the bytecode
+        // is invalid because the target of every no jump must always be reachable by yes jumps.
+        // Without this JMP, the accept target is not reachable by yes jumps and the program will
+        // be rejected by the validator.
+        { INET_DIAG_BC_JMP, jmplen, jmplen + rejectoffset },
+
+        // We have reached the end of the program. Accept the socket, and destroy it below.
+    };
+
+    struct nlattr nla = {
+        .nla_type = INET_DIAG_REQ_BYTECODE,
+        .nla_len = sizeof(struct nlattr) + bytecodelen,
+    };
+
+    iovec iov[] = {
+        { nullptr,   0 },
+        { &nla,      sizeof(nla) },
+        { &bytecode, bytecodelen },
+    };
+
+    mSocketsDestroyed = 0;
+    Stopwatch s;
+
+    auto shouldDestroy = [&] (uint8_t, const inet_diag_msg *msg) {
+        return msg != nullptr && !(excludeLoopback && isLoopbackSocket(msg));
+    };
+
+    if (int ret = destroyLiveSockets(shouldDestroy, "permission change", iov, ARRAY_SIZE(iov))) {
+        return ret;
+    }
+
+    if (mSocketsDestroyed > 0) {
+        ALOGI("Destroyed %d sockets for netId %d permission=%d in %.1f ms",
+              mSocketsDestroyed, netId, permission, s.timeTaken());
+    }
+
+    return 0;
+}
diff --git a/server/SockDiag.h b/server/SockDiag.h
index e397793..396b915 100644
--- a/server/SockDiag.h
+++ b/server/SockDiag.h
@@ -24,6 +24,7 @@
 #include <functional>
 #include <set>
 
+#include "Permission.h"
 #include "UidRanges.h"
 
 struct inet_diag_msg;
@@ -58,6 +59,10 @@ class SockDiag {
     // Destroys all "live" (CONNECTED, SYN_SENT, SYN_RECV) TCP sockets for the given UID ranges.
     int destroySockets(const UidRanges& uidRanges, const std::set<uid_t>& skipUids,
                        bool excludeLoopback);
+    // Destroys all "live" (CONNECTED, SYN_SENT, SYN_RECV) TCP sockets that no longer have
+    // the permissions required by the specified network.
+    int destroySocketsLackingPermission(unsigned netId, Permission permission,
+                                        bool excludeLoopback);
 
   private:
     friend class SockDiagTest;
@@ -66,7 +71,7 @@ class SockDiag {
     int mSocketsDestroyed;
     int sendDumpRequest(uint8_t proto, uint8_t family, uint32_t states, iovec *iov, int iovcnt);
     int destroySockets(uint8_t proto, int family, const char *addrstr);
-    int destroyLiveSockets(DumpCallback destroy);
+    int destroyLiveSockets(DumpCallback destroy, const char *what, iovec *iov, int iovcnt);
     bool hasSocks() { return mSock != -1 && mWriteSock != -1; }
     void closeSocks() { close(mSock); close(mWriteSock); mSock = mWriteSock = -1; }
     static bool isLoopbackSocket(const inet_diag_msg *msg);
diff --git a/server/SockDiagTest.cpp b/server/SockDiagTest.cpp
index f9353f3..70a199d 100644
--- a/server/SockDiagTest.cpp
+++ b/server/SockDiagTest.cpp
@@ -25,6 +25,7 @@
 
 #include <gtest/gtest.h>
 
+#include "Fwmark.h"
 #include "NetdConstants.h"
 #include "SockDiag.h"
 #include "UidRanges.h"
@@ -278,6 +279,7 @@ enum MicroBenchmarkTestType {
     UID_EXCLUDE_LOOPBACK,
     UIDRANGE,
     UIDRANGE_EXCLUDE_LOOPBACK,
+    PERMISSION,
 };
 
 const char *testTypeName(MicroBenchmarkTestType mode) {
@@ -288,10 +290,30 @@ const char *testTypeName(MicroBenchmarkTestType mode) {
         TO_STRING_TYPE(UID_EXCLUDE_LOOPBACK);
         TO_STRING_TYPE(UIDRANGE);
         TO_STRING_TYPE(UIDRANGE_EXCLUDE_LOOPBACK);
+        TO_STRING_TYPE(PERMISSION);
     }
 #undef TO_STRING_TYPE
 }
 
+static struct {
+    unsigned netId;
+    bool explicitlySelected;
+    Permission permission;
+} permissionTestcases[] = {
+    { 42, false, PERMISSION_NONE,    },
+    { 42, false, PERMISSION_NETWORK, },
+    { 42, false, PERMISSION_SYSTEM,  },
+    { 42, true,  PERMISSION_NONE,    },
+    { 42, true,  PERMISSION_NETWORK, },
+    { 42, true,  PERMISSION_SYSTEM,  },
+    { 43, false, PERMISSION_NONE,    },
+    { 43, false, PERMISSION_NETWORK, },
+    { 43, false, PERMISSION_SYSTEM,  },
+    { 43, true,  PERMISSION_NONE,    },
+    { 43, true,  PERMISSION_NETWORK, },
+    { 43, true,  PERMISSION_SYSTEM,  },
+};
+
 class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmarkTestType> {
 
 public:
@@ -305,10 +327,15 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
     constexpr static int MAX_SOCKETS = 500;
     constexpr static int ADDRESS_SOCKETS = 500;
     constexpr static int UID_SOCKETS = 50;
+    constexpr static int PERMISSION_SOCKETS = 16;
+
     constexpr static uid_t START_UID = 8000;  // START_UID + number of sockets must be <= 9999.
     constexpr static int CLOSE_UID = START_UID + UID_SOCKETS - 42;  // Close to the end
     static_assert(START_UID + MAX_SOCKETS < 9999, "Too many sockets");
 
+    constexpr static int TEST_NETID = 42;  // One of the OEM netIds.
+
+
     int howManySockets() {
         MicroBenchmarkTestType mode = GetParam();
         switch (mode) {
@@ -319,6 +346,30 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
         case UIDRANGE:
         case UIDRANGE_EXCLUDE_LOOPBACK:
             return UID_SOCKETS;
+        case PERMISSION:
+            return ARRAY_SIZE(permissionTestcases);
+        }
+    }
+
+    int modifySocketForTest(int s, int i) {
+        MicroBenchmarkTestType mode = GetParam();
+        switch (mode) {
+        case UID:
+        case UID_EXCLUDE_LOOPBACK:
+        case UIDRANGE:
+        case UIDRANGE_EXCLUDE_LOOPBACK: {
+            uid_t uid = START_UID + i;
+            return fchown(s, uid, -1);
+        }
+        case PERMISSION: {
+            Fwmark fwmark;
+            fwmark.netId = permissionTestcases[i].netId;
+            fwmark.explicitlySelected = permissionTestcases[i].explicitlySelected;
+            fwmark.permission = permissionTestcases[i].permission;
+            return setsockopt(s, SOL_SOCKET, SO_MARK, &fwmark.intValue, sizeof(fwmark.intValue));
+        }
+        default:
+            return 0;
         }
     }
 
@@ -346,6 +397,11 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
                 UidRanges uidRanges;
                 uidRanges.parseFrom(ARRAY_SIZE(uidRangeStrings), (char **) uidRangeStrings);
                 ret = mSd.destroySockets(uidRanges, skipUids, excludeLoopback);
+                break;
+            }
+            case PERMISSION: {
+                ret = mSd.destroySocketsLackingPermission(TEST_NETID, PERMISSION_NETWORK, false);
+                break;
             }
         }
         return ret;
@@ -373,6 +429,11 @@ class SockDiagMicroBenchmarkTest : public ::testing::TestWithParam<MicroBenchmar
             case UID_EXCLUDE_LOOPBACK:
             case UIDRANGE_EXCLUDE_LOOPBACK:
                 return false;
+            case PERMISSION:
+                if (permissionTestcases[i].netId != 42) return false;
+                if (permissionTestcases[i].explicitlySelected != 1) return true;
+                Permission permission = permissionTestcases[i].permission;
+                return permission != PERMISSION_NETWORK && permission != PERMISSION_SYSTEM;
         }
     }
 
@@ -424,11 +485,10 @@ TEST_P(SockDiagMicroBenchmarkTest, TestMicroBenchmark) {
     auto start = std::chrono::steady_clock::now();
     for (int i = 0; i < numSockets; i++) {
         int s = socket(AF_INET6, SOCK_STREAM, 0);
-        uid_t uid = START_UID + i;
-        ASSERT_EQ(0, fchown(s, uid, -1));
         clientlen = sizeof(client);
         ASSERT_EQ(0, connect(s, (sockaddr *) &server, sizeof(server)))
             << "Connecting socket " << i << " failed " << strerror(errno);
+        ASSERT_EQ(0, modifySocketForTest(s, i));
         serversockets[i] = accept(listensocket, (sockaddr *) &client, &clientlen);
         ASSERT_NE(-1, serversockets[i])
             << "Accepting socket " << i << " failed " << strerror(errno);
@@ -472,4 +532,5 @@ constexpr int SockDiagMicroBenchmarkTest::CLOSE_UID;
 
 INSTANTIATE_TEST_CASE_P(Address, SockDiagMicroBenchmarkTest,
                         testing::Values(ADDRESS, UID, UIDRANGE,
-                                        UID_EXCLUDE_LOOPBACK, UIDRANGE_EXCLUDE_LOOPBACK));
+                                        UID_EXCLUDE_LOOPBACK, UIDRANGE_EXCLUDE_LOOPBACK,
+                                        PERMISSION));

From d102965e157e16c5a7600616cfbabaaa7bc41acd Mon Sep 17 00:00:00 2001
From: Lorenzo Colitti <lorenzo@google.com>
Date: Mon, 26 Sep 2016 17:17:40 +0900
Subject: [PATCH 23/23] List network permissions in dumpsys netd.

Bug: 23113288

(cherry picked from commit 1f28b6403effcbf8a2c6fd35a7b1474b60bc0463)

Change-Id: I8056830bf1e458017947912261d61bc060a1f340
---
 include/Permission.h         | 10 ++++++++++
 server/NetworkController.cpp |  9 ++++++++-
 2 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/include/Permission.h b/include/Permission.h
index aa5ae81..19881df 100644
--- a/include/Permission.h
+++ b/include/Permission.h
@@ -39,4 +39,14 @@ enum Permission {
     PERMISSION_SYSTEM  = 0x3,  // Includes PERMISSION_NETWORK.
 };
 
+inline const char *permissionToName(Permission permission) {
+    switch (permission) {
+        case PERMISSION_NONE:    return "NONE";
+        case PERMISSION_NETWORK: return "NETWORK";
+        case PERMISSION_SYSTEM:  return "SYSTEM";
+        // No default statement. We want to see errors of the form:
+        // "enumeration value 'PERMISSION_SYSTEM' not handled in switch [-Werror,-Wswitch]".
+    }
+}
+
 #endif  // NETD_INCLUDE_PERMISSION_H
diff --git a/server/NetworkController.cpp b/server/NetworkController.cpp
index aaf8b29..c891391 100644
--- a/server/NetworkController.cpp
+++ b/server/NetworkController.cpp
@@ -536,7 +536,14 @@ void NetworkController::dump(DumpWriter& dw) {
     dw.println("Networks:");
     dw.incIndent();
     for (const auto& i : mNetworks) {
-        dw.println(i.second->toString().c_str());
+        Network* network = i.second;
+        dw.println(network->toString().c_str());
+        if (network->getType() == Network::PHYSICAL) {
+            dw.incIndent();
+            Permission permission = reinterpret_cast<PhysicalNetwork*>(network)->getPermission();
+            dw.println("Required permission: %s", permissionToName(permission));
+            dw.decIndent();
+        }
         android::net::gCtls->resolverCtrl.dump(dw, i.first);
         dw.blankline();
     }
